<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content="记录个人学习的博客"><meta name="author" content="Findly"><meta name="keywords" content=""><meta name="description" content="浏览器之跨域 什么是跨域？ 怎么样算跨域？ 如何解决跨域？  1.跨域的来源跨域问题的来源是浏览器为了请求安全而引入的基于同源策略的安全特性。同源策略是浏览器一个非常重要的安全策略，基于这个安全策略可以限制非同源的内容与当前页面进行交互和通信，来达到减少被攻击的目的。我们也要明白一个重点：跨域是浏览器的限制，服务端并不存在跨域的概念;当产生跨域问题时，我们可以通过JSONP、CORS,反向代理、p"><meta property="og:type" content="article"><meta property="og:title" content="浏览器之跨域"><meta property="og:url" content="http://example.com/2020/10/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E8%B7%A8%E5%9F%9F/index.html"><meta property="og:site_name" content="Findly&#39;s Blog"><meta property="og:description" content="浏览器之跨域 什么是跨域？ 怎么样算跨域？ 如何解决跨域？  1.跨域的来源跨域问题的来源是浏览器为了请求安全而引入的基于同源策略的安全特性。同源策略是浏览器一个非常重要的安全策略，基于这个安全策略可以限制非同源的内容与当前页面进行交互和通信，来达到减少被攻击的目的。我们也要明白一个重点：跨域是浏览器的限制，服务端并不存在跨域的概念;当产生跨域问题时，我们可以通过JSONP、CORS,反向代理、p"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://i.loli.net/2021/10/18/3BZtp6oFlDCUL9x.png"><meta property="article:published_time" content="2020-10-19T16:00:00.000Z"><meta property="article:modified_time" content="2021-12-21T08:37:22.199Z"><meta property="article:author" content="Findly"><meta property="article:tag" content="浏览器"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://i.loli.net/2021/10/18/3BZtp6oFlDCUL9x.png"><title>浏览器之跨域 - Findly&#39;s Blog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"example.com",root:"/",version:"1.8.12",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname"}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Findly's Blog" type="application/atom+xml"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Findly&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(/img/banner_1.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="浏览器之跨域"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-10-20 00:00" pubdate>2020年10月20日 凌晨</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 3.4k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 11 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">浏览器之跨域</h1><p class="note note-info">本文最后更新于：1 年前</p><div class="markdown-body"><h3 id="浏览器之跨域"><a href="#浏览器之跨域" class="headerlink" title="浏览器之跨域"></a>浏览器之跨域</h3><ul><li><h4 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h4></li><li><h4 id="怎么样算跨域？"><a href="#怎么样算跨域？" class="headerlink" title="怎么样算跨域？"></a>怎么样算跨域？</h4></li><li><h4 id="如何解决跨域？"><a href="#如何解决跨域？" class="headerlink" title="如何解决跨域？"></a>如何解决跨域？</h4></li></ul><h4 id="1-跨域的来源"><a href="#1-跨域的来源" class="headerlink" title="1.跨域的来源"></a>1.跨域的来源</h4><p>跨域问题的来源是浏览器为了请求安全而引入的基于<code>同源策略</code>的安全特性。同源策略是浏览器一个非常重要的安全策略，基于这个安全策略可以限制非同源的内容与当前页面进行交互和通信，来达到减少被攻击的目的。我们也要明白一个重点：<code>跨域是浏览器的限制，服务端并不存在跨域的概念</code>;当产生跨域问题时，我们可以通过<code>JSONP</code>、<code>CORS</code>,<code>反向代理</code>、<code>postMessage</code>等方式来解决</p><h4 id="2-跨域的判定"><a href="#2-跨域的判定" class="headerlink" title="2.跨域的判定"></a>2.跨域的判定</h4><p><img src="https://i.loli.net/2021/10/18/3BZtp6oFlDCUL9x.png" srcset="/img/loading.gif" lazyload alt="cors"></p><p>如上图所示，一个 origin 由<strong>协议（Protocol）</strong>、<strong>主机名（Host）</strong>和<strong>端口（Port）</strong>组成，这三块也是同源策略的判定条件，只有当<strong>协议</strong>、<strong>主机名</strong>和<strong>端口</strong>都相同时，浏览器才判定两者是同源关系，三者任一不同则为<code>跨域</code></p><h4 id="3-跨域的解决方案"><a href="#3-跨域的解决方案" class="headerlink" title="3.跨域的解决方案"></a>3.跨域的解决方案</h4><p>前端常见的跨域解决方案有<code>JSONP</code>、使用Nginx或者Node中间件做代理，利用<code>CORS</code>,<code>postMessage</code>等方式；</p><ul><li><p><code>JSONP</code></p><p><code>JSONP</code>的原理主要是利用<code>&lt;script&gt;</code>,<code>link</code>,<code>&lt;img&gt;</code>等标签的特性在加载资源文件时不受同源策略的限制能够实现跨域获取数据，但是需要前后端一起配合才能实现并且只能支持<code>GET</code>请求方式。具体步骤如下：</p><ul><li>定义一个回调函数，并且用DOM方法创建一个<code>script</code>元素</li><li>指定要请求的URL，并将回调函数作为一个参数传递过去</li><li>将<code>script</code>便签插入到当前文档中，请求开始</li><li>服务器接收到传递过来的参数，然后将回调函数和数据以调用的形式传入</li><li>当<code>script</code>标签接收到响应中的脚本代码后，就会自动执行</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createScript</span>(<span class="hljs-params">url, charset</span>) &#123;<br>    <span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>    script.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;type&#x27;</span>, <span class="hljs-string">&#x27;text/javascript&#x27;</span>);<br>    charset &amp;&amp; script.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;charset&#x27;</span>, charset);<br>    script.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;src&#x27;</span>, url);<br>    script.<span class="hljs-property">async</span> = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> script;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">jsonp</span>(<span class="hljs-params">url, onsuccess, onerror, charset</span>) &#123;<br>    <span class="hljs-keyword">const</span> hash = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>().<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-variable language_">window</span>[<span class="hljs-string">&#x27;jsonp&#x27;</span> + hash] = <span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<br>        <span class="hljs-keyword">if</span> (onsuccess &amp;&amp; <span class="hljs-title function_">typeof</span>(onsuccess) === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>            <span class="hljs-title function_">onsuccess</span>(data);<br>&#125; &#125;<br><span class="hljs-keyword">const</span> script = <span class="hljs-title function_">createScript</span>(url + <span class="hljs-string">&#x27;?callback=jsonp&#x27;</span> + hash, charset);<br><span class="hljs-comment">// 监听加载成功的事件，获取数据，这个位置用了两个事件onload和onreadystatechange是为了 兼容IE，因为IE9之前不支持onload事件，只支持onreadystatechange事件</span><br>script.<span class="hljs-property">onload</span> = script.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//若不存在readyState事件则证明不是IE浏览器，可以直接执行，若是的话，必须等到状态变为</span><br>loaded或complete才可以执行<br><span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> === <span class="hljs-string">&#x27;loaded&#x27;</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span><br>=== <span class="hljs-string">&#x27;complete&#x27;</span>) &#123;<br>script.<span class="hljs-property">onload</span> = script.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 移除该script的DOM对象</span><br><span class="hljs-keyword">if</span> (script.<span class="hljs-property">parentNode</span>) &#123;<br>                script.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">removeChild</span>(script);<br>            &#125;<br><span class="hljs-comment">// 删除函数或变量</span><br>            <span class="hljs-variable language_">window</span>[<span class="hljs-string">&#x27;jsonp&#x27;</span> + hash] = <span class="hljs-literal">null</span>;<br>        &#125;<br>&#125;;<br>    script.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (onerror &amp;&amp; <span class="hljs-title function_">typeof</span>(onerror) === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br><span class="hljs-title function_">onerror</span>(); &#125;<br>&#125;<br><span class="hljs-comment">// 添加标签，发送请求</span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;head&#x27;</span>)[<span class="hljs-number">0</span>].<span class="hljs-title function_">appendChild</span>(script);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="相关知识-跨域脚本报错怎么拿到相关信息？"><a href="#相关知识-跨域脚本报错怎么拿到相关信息？" class="headerlink" title="相关知识-跨域脚本报错怎么拿到相关信息？"></a>相关知识-跨域脚本报错怎么拿到相关信息？</h4><ul><li>当引入跨域的脚本（比如用了 apis.google.com 上的库文件）时，如果这个脚本有错误，因为浏览器的限制（根本原因是协议的规定），是拿不到错误信息的。当本地尝试使用<code>window.onerror</code>去记录脚本的错误时，跨域脚本的错误只会返回 <code>Script error</code>。</li><li>而 HTML5 新的规定，是可以允许本地获取到跨域脚本的错误信息的，但有两个条件：一是跨域脚本的服务器必须通过 <code>Access-Control-Allow-Origin</code>头信息允许当前域名可以获取错误信息，二是网页里的 <code>script</code> 标签也必须指明 src 属性指定的地址是支持跨域的地址，也就是 <code>crossorigin</code> 属性。有了这两个条件，就可以获取跨域脚本的错误信息</li></ul></li><li><p><code>CORS</code></p><p><code>CORS</code>通信流程是浏览器自动完成，不需要用户参与，其核心点是服务器，只要服务器实现了 <code>CORS</code>接口就可以实现跨源通信了。虽然是浏览器自动完成，但是浏览器其实还是根据请求时字段 的不同分为简单请求和非简单请求的;</p><ul><li><p>简单请求</p><ul><li>请求方法是一下三种方法之一:HEAD、GET、POST;</li><li>HTTP的头信息不超出以下几种字段:Accept、Accept-Language、Content-Language、Last-</li></ul><p>Event-ID、Content-Type(其值为application/x-www-form-urlencoded、multipart/form- data、text/plain三个中的一个)。</p></li><li><p>非简单请求</p><p>不是简单请求的就是非简单请求，非简单请求是那种对服务器有特殊要求的请求，比如请求方法 是PUT或Delete，或者Content-Type字段的类型是application/json。</p><ul><li><pre><code>浏览器发起预检请求，该请求的请求方法是options，该请求是用来询问的;
</code></pre></li><li><pre><code> 服务器收到“预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-
</code></pre></li></ul><p>Request-Headers字段以后，确认允许跨源请求，就可以做出回应。</p><ul><li><pre><code>如果浏览器否定了“预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字
</code></pre></li></ul><p>段，这时浏览器就会认定服务器不同意预检请求，触发错误;</p><ul><li><pre><code>如果浏览器通过了“预检”请求，以后每次浏览器正常的CORS请求就跟简单请求一样，会有一个
</code></pre></li></ul><p>Origin头信息字段，服务器的回应也会有一个Access-Control-Allow-Origin头信息字段;</p><ul><li>过服务端返回的 <code>Access-Control-Allow-*</code> 判定请求是否被允许。<ul><li><code>Access-Control-Allow-Origin</code> 表示允许的来源</li><li><code>Access-Control-Allow-Methods</code> 表示允许的请求方法</li><li><code>Access-Control-Allow-Headers</code> 表示允许的请求头</li><li><code>Access-Control-Allow-Credentials</code> 表示允许携带认证信息</li></ul></li></ul></li></ul></li><li><p><code>反向代理</code></p><p>向代理解决跨域问题的方案依赖同源的服务端对请求做一个转发处理，将请求从跨域请求转换成同源请求,在页面同域下配置一套反向代理服务，页面请求同域的服务端，服务端请求上游的实际的服务端，之后将结果返回给前端。所以反向代理前端几乎不需要做什么。</p></li></ul></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2020/10/30/%E7%AE%80%E5%8D%95%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6%E5%AE%9E%E7%8E%B0/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">简单的脚手架实现过程</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2020/08/30/%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%87%BB%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"><span class="hidden-mobile">前端实现点击下载文件的几种方法</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://findly.gitee.io/" target="_blank" rel="nofollow noopener"><span>Findly</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/local-search.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js"></script><script>!function(t){(0,Fluid.plugins.typing)(t.getElementById("subtitle").title)}((window,document))</script><script src="/js/boot.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginModelPath:"assets/",model:{jsonPath:"/live2dw/assets/shizuku.model.json"},display:{position:"right",width:200,height:250},mobile:{show:!1},rect:"opacity:0.7",log:!1,pluginJsPath:"lib/",pluginRootPath:"live2dw/",tagMode:!1})</script></body></html>