{"meta":{"title":"Findly's Blog","subtitle":"","description":"记录个人学习的博客","author":"Findly","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-11-17T02:29:53.963Z","updated":"2021-10-22T06:02:21.315Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"关于我欢迎来到我的网站 我是一名前端开发，涉及React、Vue技术栈，也是一个吃货，爱好美食，妥妥的一个干饭人。这个博客主要是记录学习、工作中的点点滴滴，各类知识点纯个人总结。 如果有不足之处，欢迎联系指出。"}],"posts":[{"title":"webpack编译提速DllPlugin和hard-source-webpack-plugin","slug":"webpack编译提速DllPlugin和hard-source-webpack-plugin","date":"2023-05-27T16:00:00.000Z","updated":"2023-05-28T04:09:30.007Z","comments":true,"path":"2023/05/28/webpack编译提速DllPlugin和hard-source-webpack-plugin/","link":"","permalink":"http://example.com/2023/05/28/webpack%E7%BC%96%E8%AF%91%E6%8F%90%E9%80%9FDllPlugin%E5%92%8Chard-source-webpack-plugin/","excerpt":"","text":"DLLPlugin一：DLLPlugin作用Webpack官网中对这两个插件的介绍：DLLPlugin 和 DLLReferencePlugin 能实现了拆分 bundles，同时还大大提升了构建的速度。实际上就是可以事先将常用的基础模块(如React、react-dom)等抽离出来，打包到一个个单独的动态链接库(dll)中去，后面再打包业务代码时若遇到需要导入的模块存在于前面打包好的某个动态链接库中时，就跳过相关的依赖的打包，直接使用动态链接库中的代码，以此来缩短webpack构建时间，提升构建速度。 二：使用介绍Webpack 内置了对动态链接库的支持，需要通过 2 个内置插件访问。DllPlugin：在一个额外的webpack配置中设置，用于将指定模块抽离，打包出动态链接库文件；DLLReferencePlugin：用于在webpack主配置文件中配置如何引入已经打包好的动态链接库文件。一般用于生产环境，开发环境会忽略一些报错提示，对开发环境不够友好 下面以user项目 为例，介绍 DllPlugin和DLLReferencePlugin的使用。 第一步：构建出动态链接库文件假设项目中需要将react、react-dom等拆分出来，打包成动态链接库文件。我们首先需要新建一个webpack配置文件，因为动态链接库相关产物需要由一份独立的构建输出。1.1 在根目录下新建Webpack配置文件webpack.dll.config.js，配置主要内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243/* * @Author: qiuwenbin &lt;qiuwenbin@wshifu.com&gt; * @Date: 2023-05-16 16:07:06 * @LastEditors: qiuwenbin * @LastEditTime: 2023-05-18 17:22:42 * @Description: */const path = require(&#x27;path&#x27;);const webpack = require(&#x27;webpack&#x27;);module.exports = &#123; // 如果更改了依赖的包文件，需要重新将编译后的包文件上传到CDN上 // webpack.common.config 的 assets 文件名也需要改成 对应的 hash 值 entry: &#123; vendor:[ &#x27;react&#x27;, &#x27;react-dom&#x27;, &#x27;react-router-dom&#x27;, &#x27;redux&#x27;, &#x27;react-router-redux&#x27;, &#x27;react-redux&#x27;, &#x27;react-loadable&#x27;, &#x27;qs&#x27;, &#x27;query-string&#x27;, &#x27;history&#x27;, &#x27;classnames&#x27;, &#x27;axios&#x27;, &#x27;rxjs&#x27;, ] &#125;, output: &#123; path: path.join(__dirname, &quot;./dist&quot;), filename: &quot;[name].dll.js&quot;, library: &quot;[name]_library&quot;, &#125;, plugins: [ new webpack.DllPlugin(&#123; path: path.join(__dirname, &#x27;./dist&#x27;, &#x27;[name].manifest.json&#x27;), name: &#x27;[name]_library&#x27; &#125;) ]&#125; 1.2 执行构建命令 12// package.json&quot;build:dll&quot;: &quot;npm run remove:dist &amp;&amp; webpack --config build/webpack.dll.config.js --mode production&quot;, 1.3 构建产物 123├── dist ├── vendor.dll.js └── vendors.manifest.json 12345678/** @license React v16.14.0 * react.production.min.js * * Copyright (c) Facebook, Inc. and its affiliates. * * This source code is licensed under the MIT license found in the * LICENSE file in the root directory of this source tree. */var r=n(68),i=&quot;function&quot;==typeof Symbol&amp;&amp;Symbol.for,o=i?Symbol.for(&quot;react.element&quot;):60103,s=i?Symbol.for(&quot;react.portal&quot;):60106,u=i?Symbol.for(&quot;react.fragment&quot;):60107,c=i?Symbol.for(&quot;react.strict_mode&quot;):60108,a=i?Symbol.for(&quot;react.profiler&quot;):60114,l=i?Symbol.for(&quot;react.provider&quot;):60109,f=i?Symbol.for(&quot;react.context&quot;):60110,p=i?Symbol.for(&quot;react.forward_ref&quot;):60112,h=i?Symbol.for(&quot;react.suspense&quot;):60113,d=i?Symbol.for(&quot;react.memo&quot;):60115,b=i?Symbol.for(&quot;react.lazy&quot;):60116,y=&quot;function&quot;==typeof Symbol&amp;&amp;Symbol.iterator;function v(t)&#123;for(var e=&quot;https://reactjs.org/docs/error-decoder.html?invariant=&quot;+t,n=1;n&lt;arguments.length;n++)e+=&quot;&amp;args[]=&quot;+encodeURIComponent(arguments[n]);return&quot;Minified React error #&quot;+t+&quot;; visit &quot;+e+&quot; for the full message or use the non-minified dev environment for full errors and additional helpful warnings.&quot;&#125;var m=&#123;isMounted:function()&#123;return!1&#125;,enqueueForceUpdate:function()&#123;&#125;,enqueueReplaceState:function()&#123;&#125;,enqueueSetState:function()&#123;&#125;&#125;,g=&#123;&#125;;function w(t,e,n)&#123;this.props=t,this.context=e,this.refs=g,this.updater=n||m&#125;function x()&#123;&#125;function O(t,e,n)&#123;this.props=t,this.context=e,this.refs=g,this.updater=n||m&#125;w.prototype.isReactComponent=&#123;&#125;,w.prototype.setState=function(t,e)&#123;if(&quot;object&quot;!=typeof t&amp;&amp;&quot;function&quot;!=typeof t&amp;&amp;null!=t)throw Error(v(85));this.updater.enqueueSetState(this,t,e,&quot;setState&quot;)&#125;,w.prototype.forceUpdate=function(t)&#123;this.updater.enqueueForceUpdate(this,t,&quot;forceUpdate&quot;)&#125;,... 产物中react_dll.js中包含了模块的代码，模块存放在一个对象中，用对象的key作为 ID。 并且还通过react_dll 变量把自己暴露在了全局中，也就是可以通过 window.react_dll(ID) 可以访问到它里面包含的模块。再看另一种产物 *.manifest.json, 类似这样： 123456789101112131415161718192021222324&#123;&quot;name&quot;: &quot;vendor_library&quot;,&quot;content&quot;: &#123; &quot;./node_modules/react/index.js&quot;: &#123; &quot;id&quot;: 0, &quot;buildMeta&quot;: &#123; &quot;providedExports&quot;: true &#125; &#125;, &quot;./node_modules/react-dom/index.js&quot;: &#123; &quot;id&quot;: 43, &quot;buildMeta&quot;: &#123; &quot;providedExports&quot;: true &#125; &#125;, &quot;./node_modules/object-assign/index.js&quot;: &#123; &quot;id&quot;: 141, &quot;buildMeta&quot;: &#123; &quot;providedExports&quot;: true &#125; &#125;, &quot;./node_modules/react/cjs/react.production.min.js&quot;: &#123; &quot;id&quot;: 201, &quot;buildMeta&quot;: &#123; &quot;providedExports&quot;: true &#125; &#125;, &quot;./node_modules/react-dom/cjs/react-dom.production.min.js&quot;: &#123; &quot;id&quot;: 369, &quot;buildMeta&quot;: &#123; &quot;providedExports&quot;: true &#125; &#125;, &quot;./node_modules/scheduler/index.js&quot;: &#123; &quot;id&quot;: 370, &quot;buildMeta&quot;: &#123; &quot;providedExports&quot;: true &#125; &#125;, &quot;./node_modules/scheduler/cjs/scheduler.production.min.js&quot;: &#123; &quot;id&quot;: 371, &quot;buildMeta&quot;: &#123; &quot;providedExports&quot;: true &#125; &#125;&#125;&#125; 可见 manifest.json 文件清楚地描述了与其对应的 dll.js 文件中包含了哪些模块，以及每个模块的路径和 ID。 第二步：在主webpack文件中使用动态链接库文件2.1 在根目录下Webpack主配置文件webpack.config.js，配置主要内容如下： 1234567891011121314151617const HtmlIncludeAssetsPlugin = require(&#x27;add-asset-html-webpack-plugin&#x27;)module.exports = &#123; ... plugins:[ new webpack.DllReferencePlugin(&#123; context: __dirname, manifest: path.resolve(__dirname, &#x27;./dist/vendor.manifest.json&#x27;), &#125;), // 将dll产物插入到html new HtmlIncludeAssetsPlugin(&#123; assets: &#x27;main.dll.js&#x27;, append: false, // publicPath: &#x27;https://qncdn.wanshifu.com/wshifu-user/js/&#x27; &#125;) ]&#125; 三、DllPlugin原理xxx.manifest.json文件name指的是对应的dll库名字，描述了哪些模块被打进来dll了， 用模块名当id标识出来 大概是一个模块清单;xxx.dll.js就是模块的源码了xxx.dll.js 是各个模块的源码集合通过key（模块id）–&gt; value查询出来 那么webpack如何查找打包好的模块呢？而不需要重复打包 1、比如index.js引入了 react 123456import React from &#x27;react&#x27;;//./node_modules/_react@16.13.1@react/index.jsconsole.log(React);2、他会去mainfest.json找模块id 其实就是react关键字拼接版本号 + index.js组成id去寻找模块即 ‘./node_modules/’+’_react@16.13.1@react’+ ‘/index.js’ 组成的id 3、找到有模块的话，就不再去打包了 hard-source-webpack-plugin一:HardSourceWebpackPlugin作用webpack编译时，每次都需要将所有模块重新编译一遍，这就会导致编译时间过慢，尤其是当项目逐渐臃肿的情况下，这种情况会越来越明显，HardSourceWebpackPlugin通过将先编译的模块存储在硬盘缓存中，以便后续编译过程中可以重用这些模块，从而加速编译过程。 二:使用介绍在webpack.dev.config.js中配置plugins即可 123456789101112131415161718192021222324252627282930313233/* * @Author: xiao·Zhang * @Date: 2018-06-06 09:24:13 * @Last Modified by: xiao·Zhang * @Last Modified time: 2019-03-25 11:16:47 * @file: 开发环境webpack参数配置 */// 引入hard-source-webpack-pluginconst HardSourceWebpackPlugin = require(&#x27;hard-source-webpack-plugin&#x27;);const FriendlyErrorsWebpackPlugin = require(&#x27;friendly-errors-webpack-plugin&#x27;);const devConfig = &#123; cache: true, mode: &#x27;development&#x27;, plugins: [ ... new HardSourceWebpackPlugin(), new FriendlyErrorsWebpackPlugin() ]&#125;;const mergeConfig = merge(&#123;//commonConfig与devConfig合并导出 customizeArray(a, b, key) &#123; /*入口app放弃合并, 采用全替换*/ if (key === &#x27;entry.app&#x27;) &#123; return b; &#125; return undefined; &#125;&#125;)(commonConfig, devConfig);module.exports = mergeConfig; 12345678910111213141516171819202122const HardSourceWebpackPlugin = require(&#x27;hard-source-webpack-plugin&#x27;)new HardSourceWebpackPlugin(&#123; // cacheDirectory是在高速缓存写入。默认情况下，将缓存存储在node_modules下的目录中，因此如 // 果清除了node_modules，则缓存也是如此 cacheDirectory: &#x27;node_modules/.cache/hard-source/[confighash]&#x27;, // Either an absolute path or relative to webpack&#x27;s options.context. // Sets webpack&#x27;s recordsPath if not already set. recordsPath: &#x27;node_modules/.cache/hard-source/[confighash]/records.json&#x27;, // configHash在启动webpack实例时转换webpack配置，并用于cacheDirectory为不同的webpack配 // 置构建不同的缓存 configHash: function(webpackConfig) &#123; // node-object-hash on npm can be used to build this. return require(&#x27;node-object-hash&#x27;)(&#123;sort: false&#125;).hash(webpackConfig); &#125;, // 当加载器，插件，其他构建时脚本或其他动态依赖项发生更改时，hard-source需要替换缓存以确保输 // 出正确。environmentHash被用来确定这一点。如果散列与先前的构建不同，则将使用新的缓存 environmentHash: &#123; root: process.cwd(), directories: [], files: [&#x27;package-lock.json&#x27;, &#x27;yarn.lock&#x27;], &#125;,&#125;) 编译产物会放入到node_modules内的.cache中的hard-source文件中(所以个人认为该插件仅能在本地开发环境使用)。在webpack编译过程中会首先去校验 package-lock.json, yarn.lock文件查看是否有依赖变化。第一次构建会比较慢需要生产缓存内容，第二次编译则会寻找是否存在编译内容提升编译速度 第一次构建：写入缓存内容、跟踪项目依赖项 第二次构建：查找缓存，提速编译 当存在缓存时，编译速度得到了很大的提升，加速打包大约在40%-50%左右; 但是当我将这件加入到webpack.build.config.js中，发现在webpack编译过程中卡住了（不知道为啥） 三：原理HardSourceWebpackPlugin实现原理跟DllPlugin类似 首先，在编译的过程中，每个模块都会被分配一个唯一标识符，这个标识符是webpack自动生成的，并且是一个数字或字符串类型的id,将编译内容作为value，以key-value的形式存储在硬盘缓存中，二次编译时HardSourceWebpackPlugin会检查模块的标识符是否存在于缓存中，存在则使用，不存在则走正常的编译流程。 DLL 与 HardSourceWebpackPlugin对比 缓存 DLL 把常用的文件存储到内存或硬盘中 把公共代码打包为dll文件放到硬盘中 再次打包时，直接取读取缓存 再次打包时，读取dll文件，不重新打包 加载时间减少 打包时间减少 1.dll应用配置相对繁琐，需要先配置webpack.dll.config.js将模块打包出来，再通过DLLReferencePlugin引入(可以利用autodll-webpack-plugin优化) 2.HardSourceWebpackPlugin插件带来的效果是显著的，现在这个功能点包含webpack5中。详情可通过https://webpack.js.org/configuration/other-options/#cache 查看。当设置 cache.type: &quot;filesystem&quot; 时，webpack 会在内部以分层方式启用文件系统缓存和内存缓存。优先级为内存缓存-&gt;文件缓存-&gt;即时编译","categories":[{"name":"项目相关","slug":"项目相关","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"项目相关","slug":"项目相关","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/"}]},{"title":"webpack源码阅读","slug":"webpack源码阅读","date":"2022-02-09T16:00:00.000Z","updated":"2023-04-06T03:20:38.019Z","comments":true,"path":"2022/02/10/webpack源码阅读/","link":"","permalink":"http://example.com/2022/02/10/webpack%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/","excerpt":"","text":"webpack入口​ 1.执行npm run build 最终找到的是webpack/bin/webpack.js ​ 2.上述文件里判断了webpack-cli是否安装， 如果安装了就执行runCli方法 ​ 3.在runCli方法里加载了webpack-cli/bin/cli.js文件 ​ 4.在cli.js中核心就是判断webpack是否安装了，如果安装了，则执行runCli方法 ​ 5.在Runcli里处理命令行参数（依赖commander第三方包），执行 new WebpackCli的时候会触发action回调(通过触发this.program.action) 而这个this.program = program(commander); ​ 6.action回调里执行了loadCommandByName方法，而在这个方法里又执行了makeCommand方法最终调用this.runWebpack 执行runWebpack时候，执行了createCompiler() 在createCompiler内部调用了webpack函数(接受配置文件和回调函数，这个函数是我们本地安装的webpack)，最终返回compiler对象，就是webpack打包的第一个核心的对象 1234567891011// 1. 引入原生的webpack 和配置信息const webpack = require(&#x27;webpack&#x27;);const config = require(&#x27;./webpack.config&#x27;);// 2. 调用webpack方法 传入配置信息 获取compiler实例const compiler = webpack(config);// 调用complier的run方法compiler.run((err,stats)=&gt;&#123; console.log(1111)&#125;) webpack执行1.webpack函数通过调用createCompiler方法生成compiler 2.在createCompiler方法内部调用new Compiler方法生成compiler实例对象;在创建了compiler对象(对象身上挂载了很多属性，其中hooks尤为重要)后还判断了plugin，挂载插件；在webpack打包过程中，插件是在compiler声明之后进行的挂载（并不代表执行） new Compiler都做了些什么？ 1.定义了run方法：例如finalCallback(最终回调)，onCompiled方法（compile完成回调） run方法（执行构建 调用this.compile方法）重点关注run方法内部调用的this.compile方法 执行构建 里面包含了webpack的构建流程 2.compile做了什么？ 在它内部包含了一个完整的打包流程 具体的模块打包是在make环节完成的，在此处只是触发了make钩子 具体做了什么需要找到make定义的地方 3.createCompiler方法内部调用WebpackOptionsApply的process(options,compiler)方法处理所有的options,内部都是采用plugin.call/plugin.apply的方法传入compiler进行“埋地雷”挂载上hooks监听事件，使用的是compiler.hooks.xxx.tap等方法订阅事件。","categories":[{"name":"工程化","slug":"工程化","permalink":"http://example.com/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"工程化","slug":"工程化","permalink":"http://example.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"前端常见攻击及防御","slug":"前端常见攻击及防御","date":"2022-01-29T16:00:00.000Z","updated":"2023-03-17T01:17:43.239Z","comments":true,"path":"2022/01/30/前端常见攻击及防御/","link":"","permalink":"http://example.com/2022/01/30/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E5%8F%8A%E9%98%B2%E5%BE%A1/","excerpt":"","text":"前端常见的攻击方式常见的攻击方式: XSS(Cross Site Scripting)跨站脚本攻击 CSRF (Scross-site request forgery)跨站请求伪造 SQL注入攻击 XSS 跨站脚本攻击允许攻击者将恶意代码植入到提供给其他用户适用的页面中； 目标：为了盗取存储在客户端的cookie或者其他网站用于识别客户端的敏感信息，一旦获取到这些信息，攻击者可以假冒合法身份与网站交互 根据攻击来源，XSS攻击可以分为一下三种： 存储型： 将恶意代码提交到数据库，网站请求将恶意代码从数据库带出，对网站进行攻击 常见于带有用户保存数据的网站功能如论坛发帖 商品评论 用户私信等 反射型 攻击者构造出特殊的URL，其中包含恶意代码，用户打开特殊URL，服务端将恶意代码从URL中取出，拼接在HTML中返回，导致在网站中执行恶意代码 恶意代码窃取用户数据并发送到攻击者的网站或者冒充用户行为，调用目标网站接口执行攻击者指定的操作 存储型和反射型XXS的区别是：存储型XSS的恶意代码存在数据库里，反射性XSS的恶意代码存在URL里 DOM型XSS 攻击者构造特殊的URL包含恶意代码，前端js取出URL中的恶意代码并执行，恶意代码窃取用户数据并发送到攻击者网站，或者冒充用户行为，调用目标网站接口执行攻击者指定的操作 DOM型XXS跟前两种XSS的区别是:DOM型XSS攻击中，取出和执行恶意代码由浏览器端完成，属于前端JavaScript自身的安全漏洞，其他两种属于服务端的安全漏洞 XXS的防御XSS攻击的两大要素 攻击者提交恶意代码 浏览器执行恶意代码 针对第一要素，在用户输入过程中，过滤掉用户输入的恶劣代码提交后端。后端写入数据库前对输入进行过滤。 在使用**.innerHTML、.outerHTML、document.write()** 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等 如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患； DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，** 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval()** 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免 CSRF CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求 一个典型的CSRF攻击有着如下的流程： 受害者登录http://a.com，并保留了登录凭证（Cookie） 攻击者引诱受害者访问了http://b.com http://b.com 向 http://a.com 发送了一个请求：http://a.com/act=xx。浏览器会默认携带http://a.com的Cookie http://a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求 http://a.com以受害者的名义执行了act=xx 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让http://a.com执行了自己定义的操作 CSRF的特点 由第三方网站发起攻击，利用用户的登录凭证冒充用户提交操作（而不是直接窃取数据） 请求方式可以是：图片URL、超链接、CORS、Form提交等，部分请求可以直接嵌入到第三方论坛或者文章中 CSRF的防御 阻止不明外域的访问同源检测Samesite Cookie 提交时要求附加本域才能获取的信息CSRF Token双重Cookie验证 SQL注入 sql注入攻击，是通过将恶意的sql查询或添加语句插入到应用的输入参数中，在后台sql服务器解析执行 流程如下所示： 找出SQL漏洞的注入点 判断数据库的类型以及版本 猜解用户名和密码 利用工具查找Web后台管理入口 入侵和破坏 预防方式如下： 严格检查输入变量的类型和格式 过滤和转义特殊字符 对访问数据库的Web应用程序采用Web应用防火墙 DDOS攻击 DDOS：分布式拒绝服务攻击（Distributed Denial of Service），简单说就是发送大量请求是使服务器瘫痪。攻击者借助公共网络，将大数量的计算机设备联合起来，向一个或多个目标进行攻击。 预防： 软件层不好做，需要硬件预防，一般云服务商都有一套完整的DDOS解决方案 采用高性能的网络设备、充足的网络带宽保障 安装专业抗DDOS防火墙 点击劫持 点击劫持（ClickJacking）指在一个Web页面中隐藏了一个透明的iframe，用外层假页面诱导用户点击，实际上是在隐藏的frame上触发了点击事件进行一些用户不知情的操作 预防手段 让iframe不能跨域访问 判断 top.location.hostname（iframe 嵌入的那个网站的域名）和 self.location.hostname （iframe 自己的域名）不一致时可以给出可能不安全的提示，用户确认安全的情况下再操作 1234if(top.loaction.hostname !== self.location.hostname)&#123; alert(&#x27;您正在访问不安全的页面，即将跳转到安全页面&#x27;) top.location.href = self.location.href&#125; 在响应头上加上X-Frame-Options:sameorigin表示相同域嵌入此页面（X-Frame-Options:deny表示禁止内嵌此页面）","categories":[{"name":"JS基础","slug":"JS基础","permalink":"http://example.com/categories/JS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"}]},{"title":"Redux原理及其简单实现","slug":"Redux实现原理","date":"2022-01-02T16:00:00.000Z","updated":"2022-01-19T10:00:30.203Z","comments":true,"path":"2022/01/03/Redux实现原理/","link":"","permalink":"http://example.com/2022/01/03/Redux%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"","text":"Redux原理及其简单实现 Redux 是 JavaScript 状态容器，提供可预测化的状态管理（说明Redux并不是React的专属，也可以用在其他框架）。 1. Redux的由来在React组件中，数据的流动是单向的，父子组件的通信可以通过props，兄弟组件的通信可以将状态提升自公共父组件中管理，但是层级过深的组件需要复用状态则会有一定的难度，所以Redux应运而生。 2. Redux的设计理念Redux将整个应用的state状态存储在唯一的Store中，组件只能够通过dispatch分发一个action(描述如何修改state)给Store,而不是直接通知组件，组件通过connect与Store相连接，这样能够订阅Store中的状态，由此来更新自己的视图，Connect既是组件读state状态，修改state状态的中间桥梁，而reducer规范了state的修改流程。这样在业务代码中我们只需要发起动作即可，将数据状态修改与业务代码解耦。 3.Redux的三大原则 单一数据源整个应用的数据存储在一个统一的状态树中，也就是我们前面所说的公共的store 文件。在组件都会从这个store中获取数据。 state只读组件无法直接修改state，只能通过dispatch一个action来触发状态的修改，使得状态修改有迹可循 reducer只能是纯函数reducer接收先前的 state 和 action，并返回新的 state。 4. Redux的实现Redux利用发布订阅设计模式，个人认为最难理解的是connect高阶函数部分，这也是整个Redux的核心所在,connect接受一个组件作为参数，将更新组件的内部状态定义在connect内部，将组件触发的每个修改组件状态的函数(setState)存在Store的一个listeners数组中,一旦Store中state发生改变，则遍历listeners调用setState，这样传入connect的组件就能更新视图并且获取最新的状态数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/* * @Author: Findly &lt;wenbinqiu42@gmail.com&gt; * @Date: 2022-01-18 10:05:52 * @LastEditors: Findly * @LastEditTime: 2022-01-19 17:23:42 * @Description: */import React, &#123; useState, useEffect &#125; from &#x27;react&#x27;;import &#123; changed &#125; from &#x27;./utils/utils&#x27;;let state = null;let reducer = undefined;let listeners = [];// state变化 遍历listeners 更新每个connect的视图const setState = (newState) =&gt; &#123; state = newState; listeners.map((fn) =&gt; fn(state));&#125;;const store = &#123; getState: () =&gt; &#123; return state; &#125;, dispatch: (action) =&gt; &#123; setState(reducer(state, action)); &#125;, //收集所有订阅者，并返回取消订阅方法 subscribe(fn) &#123; listeners.push(fn); return () =&gt; &#123; const index = listeners.indexOf(fn); listeners.splice(index, 1); &#125;; &#125;,&#125;;// 通过修改dispatch，内部针对不同的action做单独处理，达到实现异步action的目的（中间件的实现原理）let prevDispatch = store.dispatch;let dispatch = (action) =&gt; &#123; // 支持函数action if (action instanceof Function) &#123; action(dispatch); // 支持异步promise函数 &#125; else if (action.payload instanceof Promise) &#123; action.payload.then((resp) =&gt; &#123; dispatch(&#123; ...action, payload: resp &#125;); &#125;); &#125; else &#123; prevDispatch(action); &#125;&#125;;store.dispatch = dispatch;// 创建storeexport const createStore = (_reducer, initState) =&gt; &#123; state = initState; reducer = _reducer; return store;&#125;;// connect 链接组件和state ：读state，修改stateexport const connect = (selector, mapDispatchToProps) =&gt; (Component) =&gt; &#123; return (props) =&gt; &#123; // 触发Component组件更新的真正状态。一旦update，则Connect高阶组件rerender，Component也rerender const [, update] = useState(&#123;&#125;); const data = selector ? selector(state) : &#123; state &#125;; const dispatchs = mapDispatchToProps ? mapDispatchToProps(store.dispatch) : &#123; dispatch: store.dispatch &#125;; useEffect( () =&gt; store.subscribe(() =&gt; &#123; // 对比当前data跟上次data 精准控制是否需要更新 const newData = selector ? selector(state) : &#123; state &#125;; if (changed(data, newData)) &#123; update(&#123;&#125;); &#125; &#125;), [selector] ); return &lt;Component &#123;...props&#125; &#123;...data&#125; &#123;...dispatchs&#125; /&gt;; &#125;;&#125;;// 利用context 将Store数据作为全局状态const appContext = React.createContext(null);export const Provider = (&#123; store, children &#125;) =&gt; &#123; return &lt;appContext.Provider value=&#123;store&#125;&gt;&#123;children&#125;&lt;/appContext.Provider&gt;;&#125;; 总结虽然并没有看过Redux的相关源码，但是通过学习它的原理之后，来实现一个简单Redux其实也不是很复杂，在这里贴上相应代码的github，demo中有使用自定的redux测试，&#x1F449;redux的简单实现,推荐一个相关Redux原理与实现的B站视频，代码循序渐进通俗易懂&#x1F449;手写Redux","categories":[{"name":"框架-React","slug":"框架-React","permalink":"http://example.com/categories/%E6%A1%86%E6%9E%B6-React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"本地调试react-17.0.2源码环境搭建","slug":"本地调试react-17.0.2源码环境搭建","date":"2021-12-29T16:00:00.000Z","updated":"2021-12-30T07:39:28.312Z","comments":true,"path":"2021/12/30/本地调试react-17.0.2源码环境搭建/","link":"","permalink":"http://example.com/2021/12/30/%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95react-17.0.2%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"本地调试react-17.0.2源码环境搭建第一步 ： 创建一个react项目 首先通过官方脚手架 create-react-app 创建一个 react 项目，在终端执行以下命令 1npx create-react-app my-debug-react 暴露webpack.config.js配置 12345# 会得到一个config文件夹，里面就是react的webpack配置文件cd ./my-debug-reactyarn eject # 出现交互命令选择y即可 第二步：修改react引用 由于 node_modules 中的 react 包是打包好之后的文件，许多代码掺杂在一个文件中，不便于我们对源码进行调试。因此在 my-debug-react 的 src 目录下引入 react 的源码 123456# 加me. 是因为我配置了个人github keygit clone git clone git@me.github.com:facebook/react.git -b 17.0.2 # 接下来进入到src/react安装依赖cd ./src/react yarn 修改webpack.config.js内alias配置，加上如下配置： 1234&#x27;react&#x27;: path.resolve(__dirname, &#x27;../src/react/packages/react&#x27;),&#x27;react-dom&#x27;: path.resolve(__dirname, &#x27;../src/react/packages/react-dom&#x27;),&#x27;shared&#x27;: path.resolve(__dirname, &#x27;../src/react/packages/shared&#x27;),&#x27;react-reconciler&#x27;: path.resolve(__dirname, &#x27;../src/react/packages/react-reconciler&#x27;), 我们将 __DEV__ 等环境变量默认启用，便于开发调试,修改config/env.js,修改为如下配置： 12345678910const stringified = &#123; __DEV__: true, __PROFILE__: true, __UMD__: true, __EXPERIMENTAL__: true, &#x27;process.env&#x27;: Object.keys(raw).reduce((env, key) =&gt; &#123; env[key] = JSON.stringify(raw[key]); return env; &#125;, &#123;&#125;), &#125;; 根目录下新建.eslintrc.json文件，加入如下配置: 12345678910&#123; &quot;extends&quot;: &quot;react-app&quot;, &quot;globals&quot;: &#123; &quot;__DEV__&quot;: true, &quot;__PROFILE__&quot;: true, &quot;__UMD__&quot;: true, &quot;__EXPERIMENTAL__&quot;: true &#125;&#125; 在react的入口文件index.js中修改react、react-dom的引入方式 1234//import React from &#x27;react&#x27;;//import ReactDOM from &#x27;react-dom&#x27;;import * as React from &#x27;react&#x27;;import * as ReactDOM from &#x27;react-dom&#x27;; 最后一步：解决报错 ‼️ ⚠️ 注意：这些配置修改仅在17.0.2版本（2021-12-30）有效，不敢保证其他版本通用，如果一通配置后还是无法跑通项目，建议百度谷歌 添加 ReactFiberHostConfig 引用 直接修改src/react/packages/react-reconciler/src/ReactFiberHostConfig.js文件 12345//import invariant from &#x27;shared/invariant&#x27;;// invariant(false, &#x27;This module must be shimmed by a specific renderer.&#x27;);export * from &#x27;./forks/ReactFiberHostConfig.dom&#x27; 修改src/react/packages/shared/ReactSharedInternals.js 123456// import * as React from &#x27;react&#x27;;// const ReactSharedInternals =// React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;import ReactSharedInternals from &#x27;../react/src/ReactSharedInternals&#x27;;export default ReactSharedInternals; 修改 src/react/packages/shared/invariant.js 123456789// 加上condition判断export default function invariant(condition, format, a, b, c, d, e, f) &#123; if (condition) return; throw new Error( &#x27;Internal React error: invariant() is meant to be replaced at compile &#x27; + &#x27;time. There is no runtime version.&#x27;, );&#125; 修改src/react/.eslintrc.json文件，主要去除extends和plugin的fbjs和react 另外如果有其他react-internal,找到对应的eslint规则注释一下就好了 成果就这样，在一通百度谷歌之后，解决了各种报错问题等疑难杂症之后。我们的调试环境就搭建完成了，可以在 react 源码中通过 debugger 打断点或者 console.log() 输出日志进行愉快地调试了！ 最后贴一下我搭建的调试环境的 github 地址：my-debug-react，不想自己搭建调试环境的话可以直接 clone 我搭好的环境使用。","categories":[{"name":"框架-React","slug":"框架-React","permalink":"http://example.com/categories/%E6%A1%86%E6%9E%B6-React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"增加全局axios拦截器优化项目查询需求","slug":"增加axios拦截器优化项目需求","date":"2021-12-01T16:00:00.000Z","updated":"2021-12-23T07:10:11.610Z","comments":true,"path":"2021/12/02/增加axios拦截器优化项目需求/","link":"","permalink":"http://example.com/2021/12/02/%E5%A2%9E%E5%8A%A0axios%E6%8B%A6%E6%88%AA%E5%99%A8%E4%BC%98%E5%8C%96%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82/","excerpt":"","text":"增加全局axios拦截器优化项目查询需求前言 项目中配置了DS的autoQuery在每次进入页面都会自动查询（记为第一次查询），用户没等到第一次查询结果返回，手动选择查询条件查询（记为第二次查询）；第二次查询耗时更短先返回数据，第一次后返回。结果是用户查询条件获取的结果被第一次页面自动查询结果覆盖。 思考 这应该是所有hzero-front工程化项目的通病，并发请求对于同一数据源会出现覆盖现象，一开始想到了采用Promise.race去解决这个问题，但是这不能保证拿到的数据是正确的，使用axios拦截器的话在一定程度上也能够减少服务器访问降低服务器压力，提高性能 解决方案： 给Content加loding在autoQuery完成之前不让用户输入查询条件 ❌由于项目的整体结构是Header、Content、Footer结构，所以可以在Content外面加一层Spin，在请求完成期间有一个loding效果查询框等不能输入；这样导致用户不友好于是放弃这个方案 修改DS调用接口逻辑，将并发接口调用改成串行调用 ❌翻阅了一下DS源码了解了一下DS查询的大致过程；通过函数调用可以发现每次执行一个请求都是加入到pending的promise队列中，然后并发查询;但是如果要改成串行不太合理，如果接口过慢会导致后续接口pending现象。以下是query调用的过程，大致分析如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// TODO：1.autoquery为true 执行this.query if (autoQuery &amp;&amp; typeof window !== &#x27;undefined&#x27;) &#123; this.query(); &#125; else if (autoCreate &amp;&amp; this.records.length === 0) &#123; this.create(); &#125; /** * 查询记录 * @param page 页码 * @param params 查询参数 * @return Promise */ query(page?: number, params?: object): Promise&lt;any&gt; &#123; //TODO: 2. this.pending是一个promise队列，promise队列中加入this.doQuery return this.pending.add(this.doQuery(page, params)); &#125; async doQuery(page, params?: object): Promise&lt;any&gt; &#123; // TODO: 3. doQuery执行查询调用this.read查询 拿到data 返回 const data = await this.read(page, params); this.loadDataFromResponse(data); return data; &#125; // TODO: 3.1 查询 private async read(page: number = 1, params?: object): Promise&lt;any&gt; &#123; if (this.checkReadable(this.parent)) &#123; try &#123; this.changeStatus(DataSetStatus.loading); // TODO:3.1.1 拿到queryParams 具体要进入this.generateQueryParameter查看 const data = await this.generateQueryParameter(params); //TODO:3.1.2 处理生成config 类似axios拦截器内config const newConfig = axiosConfigAdapter(&#x27;read&#x27;, this, data, this.generateQueryString(page)); if (newConfig.url) &#123; //TODO: 如果有url 触发fireEvent，执行ds.query const queryEventResult = await this.fireEvent(DataSetEvents.query, &#123; dataSet: this, params: newConfig.params, data: newConfig.data, &#125;); if (queryEventResult) &#123; const result = await this.axios(fixAxiosConfig(newConfig)); runInAction(() =&gt; &#123; if (page &gt;= 0) &#123; this.currentPage = page; &#125; &#125;); return this.handleLoadSuccess(result); &#125; &#125; &#125; catch (e) &#123; this.handleLoadFail(e); throw new DataSetRequestError(e); &#125; finally &#123; this.changeStatus(DataSetStatus.ready); &#125; &#125; &#125; // TODO: 从这里可以看出 promise的调用是并发的 @action fireEvent(eventName: string, ...rest: any[]): Promise&lt;boolean&gt; &#123; const events: Handler[] | undefined = this.events[eventName.toLowerCase()]; return events ? Promise.all([...events].map((handle) =&gt; callHandler(events, handle, ...rest))).then(all =&gt; all.every(result =&gt; result !== false), ) : Promise.resolve(true); &#125; 使用axios+DS接口特定属性字段对指定接口进行拦截 &#x2705;axios前置知识&#x1F449;axios 的拦截器理解与使用； 在/src/utils目录下新建c7nConfig.js文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/* * @Author: Findly &lt;wenbinqiu42@gmail.com&gt; * @Date: 2021-12-15 16:10:40 * @LastEditors: Findly * @LastEditTime: 2021-12-17 16:04:21 * @Description: */import axios from &#x27;axios&#x27;;import &#123; API_HOST &#125; from &#x27;utils/config&#x27;;import &#123; getAccessToken &#125; from &#x27;utils/utils&#x27;;import &#123; getMenuId &#125; from &#x27;utils/menuTab&#x27;;import &#123; addPending, removePending &#125; from &#x27;./c7nConfigUtils&#x27;;axios.interceptors.request.use( config =&gt; &#123; let &#123; url = &#x27;&#x27; &#125; = config; if (url.indexOf(&#x27;://&#x27;) === -1 &amp;&amp; !url.startsWith(&#x27;/_api&#x27;)) &#123; url = `$&#123;API_HOST&#125;$&#123;url&#125;`; &#125; if (config.blockMutiQuery) &#123; // 拿到接口中的blockMutiQuery配置字段 removePending(config); // 在请求开始前，对之前的请求做检查取消操作 addPending(config); // 将当前请求添加到 pending 中 &#125; // Do something before request is sent const MenuId = getMenuId(); if (MenuId) &#123; return &#123; ...config, url, headers: &#123; ...config.headers, Authorization: `bearer $&#123;getAccessToken()&#125;`, &#x27;H-Menu-Id&#x27;: `$&#123;getMenuId()&#125;`, &#125;, &#125;; &#125; else &#123; return &#123; ...config, url, headers: &#123; ...config.headers, Authorization: `bearer $&#123;getAccessToken()&#125;`, &#125;, &#125;; &#125; &#125;, error =&gt; // Do something with request error console.log(&#x27;请求已被取消&#x27;, error));axios.interceptors.response.use( response =&gt; &#123; const &#123; status, data, config &#125; = response; removePending(config); // 在请求结束后，移除本次请求 if (status === 204) &#123; return undefined; &#125; if (data &amp;&amp; data.failed) &#123; throw data; &#125; else &#123; return response; &#125; &#125;, err =&gt; &#123; console.log(&#x27;请求已被取消&#x27;, err); &#125;); 抽离工具方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* * @Author: Findly &lt;wenbinqiu42@gmail.com&gt; * @Date: 2021-12-15 16:36:33 * @LastEditors: Findly * @LastEditTime: 2021-12-21 15:43:30 * @Description: */import axios from &#x27;axios&#x27;;import &#123; isEmpty &#125; from &#x27;lodash&#x27;;// 声明一个 Map 用于存储每个请求的标识 和 取消函数const pending = new Map();/** * 添加请求 * @param &#123;Object&#125; config */const addPending = config =&gt; &#123; if (!isEmpty(config)) &#123; const urlArr = [config.method, config.url]; const url = urlArr.join(&#x27;&amp;&#x27;); config.cancelToken = new axios.CancelToken(cancel =&gt; &#123; if (!pending.has(url)) &#123; // 如果 pending 中不存在当前请求，则添加进去 pending.set(url, cancel); &#125; &#125;); &#125;&#125;;/** * 移除请求 * @param &#123;Object&#125; config */const removePending = config =&gt; &#123; if (!isEmpty(config)) &#123; const urlArr = [config.method, config.url]; const url = urlArr.join(&#x27;&amp;&#x27;); if (pending.has(url)) &#123; // 如果在 pending 中存在当前请求标识，需要取消当前请求，并且移除 const cancel = pending.get(url); cancel(url); pending.delete(url); &#125; &#125;&#125;;/** * 清空 pending 中的请求（在路由跳转时调用） */const clearPending = () =&gt; &#123; for (const [url, cancel] of pending) &#123; cancel(url); &#125; pending.clear();&#125;;export &#123; addPending, removePending, clearPending &#125;; 在根文件夹的app.tsx中引入文件 1234//app.tsxexport const dvaAppInit = () =&gt; &#123; require(&#x27;./utils/c7nConfig&#x27;);&#125;; 在需要拦截的DS接口中增加blockMutiQuery字段 123456789101112131415161718192021222324transport: &#123; read: (config) =&gt; &#123; const url = `$&#123;SRM_MDM&#125;/v1/$&#123;organizationId&#125;/uniqlo-item/req`; const allParams = &#123; ...config.data, ...config.data.creationDate, &#125;; const &#123; creationDate, creator, ...queryParams &#125; = allParams; Object.keys(queryParams).forEach((key) =&gt; &#123; const value = queryParams[key]; if (value === &#x27;&#x27; || value === null) &#123; delete queryParams[key]; &#125; &#125;); const axiosConfig = &#123; ...config, data: queryParams, url, method: &#x27;GET&#x27;, blockMutiQuery: true, // 增加取消多次查询字段 &#125;; return axiosConfig; &#125;, &#125;, 效果如下： 使用axios拦截器+DS特定字段对特定接口做拦截操作能够达到需求目的，但是可以看到把Table的loading给干掉了这一点还需要优化","categories":[{"name":"项目相关","slug":"项目相关","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"项目相关","slug":"项目相关","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/"}]},{"title":"从0到1实现一个promise","slug":"从0到1实现一个promise","date":"2021-11-19T16:00:00.000Z","updated":"2021-12-21T08:34:43.469Z","comments":true,"path":"2021/11/20/从0到1实现一个promise/","link":"","permalink":"http://example.com/2021/11/20/%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AApromise/","excerpt":"","text":"从0到1实现一个Promise基本概念 Promise 是异步编程的一种解决方案,简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理—摘抄自《ECMAScript 6 入门》 三个状态 pending(进行中) fulfilled(已完成) rejected(已失败) 这三种状态只能从pending到fulfilled或者rejected，一旦状态发生了改变，则不会再改变；且状态的改变只能由执行器函数中的resolve和reject改变。 使用 Promise.resolve 返回一个成功或者失败的promise对象 传入一个非promise对象,得到一个成功的promise对象，且值为传入的值 123456789 let p = Promise.resolve(123); console.log(p);/*Promise &#123;&lt;fulfilled&gt;: 123&#125;[[Prototype]]: Promise[[PromiseState]]: &quot;fulfilled&quot;[[PromiseResult]]: 123*/ 传入一个成功的promise对象,得到一个成功的promise对象，且值为传入promise对象的值 12345678910111213let p = Promise.resolve( new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;邱文斌&#x27;); &#125;) );console.log(p);/*Promise &#123;&lt;fulfilled&gt;: &#x27;邱文斌&#x27;&#125;[[Prototype]]: Promise[[PromiseState]]: &quot;fulfilled&quot;[[PromiseResult]]: &quot;邱文斌&quot;*/ 传入一个失败的promise对象,得到一个失败的promise对象，且值为传入promise对象的值 12345678910111213let p = Promise.resolve( new Promise((resolve, reject) =&gt; &#123; reject(&#x27;邱文斌&#x27;); &#125;) );console.log(p);/*Promise &#123;&lt;rejected&gt;: &#x27;邱文斌&#x27;&#125;[[Prototype]]: Promise[[PromiseState]]: &quot;rejected&quot;[[PromiseResult]]: &quot;邱文斌&quot;*/ Promise.reject 返回一个失败的promise对象 传入一个非promise对象,得到一个失败的promise对象，且值为传入的值 12345678 let p = Promise.reject(123); console.log(p);/*Promise &#123;&lt;rejected&gt;: 123&#125;[[Prototype]]: Promise[[PromiseState]]: &quot;rejected&quot;[[PromiseResult]]: 123*/ 传入一个promise对象,都是得到一个失败的promise对象，且值为传入promise对象的值 12345678910111213141516let p = Promise.reject( new Promise((resolve, reject) =&gt; &#123; resolve(123); &#125;));console.log(p);--------------let p = Promise.reject( new Promise((resolve,reject)=&gt;&#123; reject(123) &#125;))console.log(p) Promise.all 返回一个新的promise对象，只有所有promise都成功才成功，只有一个失败就直接失败 12345678910111213141516171819202122232425const p1 = Promise.resolve(123);const p2 = Promise.resolve(456);const p3 = Promise.reject(123);const p = Promise.all([p1, p2, p3]);console.log(p);// 得到p为失败的promise对象/*Promise &#123;&lt;pending&gt;&#125;[[Prototype]]: Promise[[PromiseState]]: &quot;rejected&quot;[[PromiseResult]]: 123*/const p1 = Promise.resolve(123);const p2 = Promise.resolve(456);const p3 = Promise.resolve(789);const p = Promise.all([p1, p2, p3]);console.log(p);// 得到一个成功的promise,结果为数组/*Promise &#123;&lt;pending&gt;&#125;[[Prototype]]: Promise[[PromiseState]]: &quot;fulfilled&quot;[[PromiseResult]]: Array(3)*/ Promise.race 返回一个新的promise，第一个完成的promise的结果状态就是最终结果状态 1234567const p1 = Promise.resolve(123);const p2 = Promise.resolve(456);const p3 = Promise.resolve(789);const p = Promise.race([p1, p2, p3]);console.log(p);// p1是最先完成的 所以p的结果是p1的结果 关键问题梳理 &#x2757; 如何改变promise状态？ resolve(value):当前状态从pending变为fulfilled reject(reason):当前状态从pending变为rejected 一个promise指定多个成功/失败回调函数都会回调吗？当promise状态改变时都会调用回调函数 改变promise状态和指定回调函数谁先谁后？都有可能，正常情况下是先指定回调再改变状态，但是也可以先改变状态再指定回调 如何先改状态再执行回调？ 在Promise的执行器函数中直接执行resolve/reject函数 延迟更长时间再调用then() 什么时候才能得到数据？ 如果先指定的回调，那当状态发生改变时，回调函数就会调用得到数据 如果先改变状态，当指定回调函数时，回调函数就会调用得到数据 promise.then()返回的新promise对象的结果状态由什么决定？ 如果抛出异常，新promise变为rejected，reason为抛出的异常 如果返回的是非promise的任意值，新promise变为resolved,value为返回的值 如果返回的是一个新的promise对象，此promise对象的结果就成为了promise.then返回xinpromise对象的结果 如何中断Promise链 在回调函数中返回一个pending状态的promise则会中断promise的链式调用，因为只有状态改变了回到函数才会调用，pending状态的promise不会调用回调函数 123456789new Promise((resolve,reject)=&gt;&#123; // 异步调用&#125;).then(res=&gt;&#123; // 再次异步调用,想在这中断下一个then调用 return new Promise(()=&gt;&#123;&#125;) // 返回一个pending状态的promise实例对象，即中断promise调用 &#125;).then(resp=&gt;&#123; &#125;) 如何中断fetch 123456789101112131415161718192021// 如果需要中断一个 fetch() 操作，只需从一个 AbortController 对象获取 signal，并将这个信号对象作为 fetch() 的选项传入。大概就是这样：const ac = new AbortController();const &#123;signal&#125; = ac;fetch(url, &#123;signal&#125;).then(res =&gt; &#123; // TODO 处理业务 &#125;);// 1 秒后取消 fetch 操作setTimeout(() =&gt; ac.abort(), 1000);/*ac.abort() 会向 signal 发送信号，触发它的 abort 事件，并将其.aborted 属性置为 true。fetch() 内部处理会利用这些信息中止掉请求。上面这个示例演示了如何实现fetch() 操作的超时处理。如果使用 await 的形式来处理，需要把setTimeout(...) 放在fetch(...) 之前：*/const ac = new AbortController();const &#123;signal&#125; = ac;setTimeout(() =&gt; ac.abort(), 1000);const res = await fetch(url, &#123;signal&#125;).catch(() =&gt; undefined); Promise实现 我们要手写一个Promise，那么我们就要遵循 Promise/A+ 规范，业界所有 Promise 的类库都遵循这个规范。 Promise/A+ 规范对如何实现一个符合标准的 Promise 类库阐述的很详细。 promise 有三个状态：pending，fulfilled，or rejected；「规范 Promise/A+ 2.1」 new promise时， 需要传递一个executor()执行器，执行器立即执行； executor接受两个参数，分别是resolve和reject； promise 的默认状态是 pending； promise 有一个value保存成功状态的值，可以是undefined/thenable/promise；「规范 Promise/A+ 1.3」 promise 有一个reason保存失败状态的值；「规范 Promise/A+ 1.5」 promise 只能从pending到rejected, 或者从pending到fulfilled，状态一旦确认，就不会再改变； promise 必须有一个then方法，then 接收两个参数，分别是 promise 成功的回调 onFulfilled, 和 promise 失败的回调 onRejected；「规范 Promise/A+ 2.2」 如果调用 then 时，promise 已经成功，则执行onFulfilled，参数是promise的value； 如果调用 then 时，promise 已经失败，那么执行onRejected, 参数是promise的reason； 如果 then 中抛出了异常，那么就会把这个异常作为参数，传递给下一个 then 的失败的回调onRejected； 普通版本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162function Promise(executor) &#123; this.PromiseState = &#x27;pending&#x27;; this.PromiseResult = null; this.callbacks = []; // 保存pending回调函数 const self = this; function resolve(data) &#123; if (self.PromiseState === &#x27;pending&#x27;) &#123; // 1.修改对象状态 self.PromiseState = &#x27;fulfilled&#x27;; // 2.设置对象结果 self.PromiseResult = data; // 3.如果是异步 则遍历callbacks依次执行保存的回调函数 setTimeout(() =&gt; &#123; self.callbacks.forEach((i) =&gt; &#123; i.onResolved(data); &#125;); &#125;); &#125; &#125; function reject(reason) &#123; if (self.PromiseState === &#x27;pending&#x27;) &#123; // 1.修改对象状态 self.PromiseState = &#x27;rejected&#x27;; // 2.设置对象结果 self.PromiseResult = reason; // 3.如果是异步, 则遍历callbacks依次执行保存的回调函数,也要用setTimeout保证是异步执行 setTimeout(() =&gt; &#123; self.callbacks.forEach((i) =&gt; &#123; i.onRejected(reason); &#125;); &#125;); &#125; &#125; // 同步调用执行器函数 try &#123; executor(resolve, reject); &#125; catch (error) &#123; reject(error); &#125;&#125;Promise.prototype.then = function (onResolved, onRejected) &#123; const self = this; if (typeof onResolved !== &#x27;function&#x27;) &#123; onResolved = (value) =&gt; value; &#125; if (typeof onRejected !== &#x27;function&#x27;) &#123; // catch 透传 如果then没传第二个参数就给默认值 onRejected = (reason) =&gt; &#123; throw reason; &#125;; &#125; return new Promise((resolve, reject) =&gt; &#123; // 状态为成功 function callback(type) &#123; try &#123; // 获取回到函数执行的结果 let result = type(self.PromiseResult); // 判断结果 if (result instanceof Promise) &#123; result.then( (v) =&gt; &#123; resolve(v); &#125;, (r) =&gt; reject(r) ); &#125; else &#123; resolve(result); &#125; &#125; catch (error) &#123; reject(error); &#125; &#125; if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; // 因为then方法属于微任务 异步执行，所以要加上setTimeout修改它的执行顺序 setTimeout(() =&gt; &#123; callback(onResolved); &#125;); &#125; // 状态为失败 if (this.PromiseState === &#x27;rejected&#x27;) &#123; setTimeout(() =&gt; &#123; callback(onRejected); &#125;); &#125; // 状态为pending 处理异步任务setTimeout(()=&gt;resolve) if (this.PromiseState === &#x27;pending&#x27;) &#123; // 保存回调函数 this.callbacks.push(&#123; onResolved: function () &#123; callback(onResolved); &#125;, onRejected: function () &#123; callback(onRejected); &#125;, &#125;); &#125; &#125;);&#125;;Promise.prototype.catch = function (onRejected) &#123; return this.then(undefined, onRejected);&#125;;Promise.resolve = function (value) &#123; return new Promise((resolve, reject) =&gt; &#123; if (value instanceof Promise) &#123; value.then( (res) =&gt; resolve(res), (err) =&gt; reject(err) ); &#125; else &#123; resolve(value); &#125; &#125;);&#125;;Promise.reject = function (reason) &#123; return new Promise((resolve, reject) =&gt; &#123; reject(reason); &#125;);&#125;;Promise.all = function (promiseArr) &#123; return new Promise((resolve, reject) =&gt; &#123; // 都成功 则成功 let len = promiseArr.length; let count = 0; // 计数 let result = []; // 结果数组 for (let i = 0; i &lt; len; i++) &#123; promiseArr[i].then( (res) =&gt; &#123; result[i] = res; count++; // 从这里得知是成功 if (count === len) &#123; resolve(result); &#125; &#125;, (err) =&gt; &#123; reject(err); &#125; ); &#125; &#125;);&#125;;Promise.race = function (promiseArr) &#123; return new Promise((resolve, reject) =&gt; &#123; let len = promiseArr.length; for (let i = 0; i &lt; len; i++) &#123; // 谁先改变状态 就决定结果 promiseArr[i].then( (res) =&gt; &#123; resolve(res); &#125;, (err) =&gt; &#123; reject(err); &#125; ); &#125; &#125;);&#125;; Class 版本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150const PENDING = &#x27;PENDING&#x27;;const FULFILLED = &#x27;FULFILLED&#x27;;const REJECTED = &#x27;REJECTED&#x27;;const resolvePromise = (promise2, x, resolve, reject) =&gt; &#123; // 自己等待自己完成是错误的实现，用一个类型错误，结束掉 promise Promise/A+ 2.3.1 if (promise2 === x) &#123; return reject(new TypeError(&#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27;)); &#125; // Promise/A+ 2.3.3.3.3 只能调用一次 let called; // 后续的条件要严格判断 保证代码能和别的库一起使用 if ((typeof x === &#x27;object&#x27; &amp;&amp; x != null) || typeof x === &#x27;function&#x27;) &#123; try &#123; // 为了判断 resolve 过的就不用再 reject 了（比如 reject 和 resolve 同时调用的时候） Promise/A+ 2.3.3.1 let then = x.then; if (typeof then === &#x27;function&#x27;) &#123; // 不要写成 x.then，直接 then.call 就可以了 因为 x.then 会再次取值，Object.defineProperty Promise/A+ 2.3.3.3 then.call( x, (y) =&gt; &#123; // 根据 promise 的状态决定是成功还是失败 if (called) return; called = true; // 递归解析的过程（因为可能 promise 中还有 promise） Promise/A+ 2.3.3.3.1 resolvePromise(promise2, y, resolve, reject); &#125;, (r) =&gt; &#123; // 只要失败就失败 Promise/A+ 2.3.3.3.2 if (called) return; called = true; reject(r); &#125; ); &#125; else &#123; // 如果 x.then 是个普通值就直接返回 resolve 作为结果 Promise/A+ 2.3.3.4 resolve(x); &#125; &#125; catch (e) &#123; // Promise/A+ 2.3.3.2 if (called) return; called = true; reject(e); &#125; &#125; else &#123; // 如果 x 是个普通值就直接返回 resolve 作为结果 Promise/A+ 2.3.4 resolve(x); &#125;&#125;;class Promise &#123; constructor(executor) &#123; this.status = PENDING; this.value = undefined; this.reason = undefined; this.onResolvedCallbacks = []; this.onRejectedCallbacks = []; let resolve = (value) =&gt; &#123; if (this.status === PENDING) &#123; this.status = FULFILLED; this.value = value; this.onResolvedCallbacks.forEach((fn) =&gt; fn()); &#125; &#125;; let reject = (reason) =&gt; &#123; if (this.status === PENDING) &#123; this.status = REJECTED; this.reason = reason; this.onRejectedCallbacks.forEach((fn) =&gt; fn()); &#125; &#125;; try &#123; executor(resolve, reject); &#125; catch (error) &#123; reject(error); &#125; &#125; then(onFulfilled, onRejected) &#123; //解决 onFufilled，onRejected 没有传值的问题 //Promise/A+ 2.2.1 / Promise/A+ 2.2.5 / Promise/A+ 2.2.7.3 / Promise/A+ 2.2.7.4 onFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : (v) =&gt; v; //因为错误的值要让后面访问到，所以这里也要跑出个错误，不然会在之后 then 的 resolve 中捕获 onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : (err) =&gt; &#123; throw err; &#125;; // 每次调用 then 都返回一个新的 promise Promise/A+ 2.2.7 let promise2 = new Promise((resolve, reject) =&gt; &#123; if (this.status === FULFILLED) &#123; //Promise/A+ 2.2.2 //Promise/A+ 2.2.4 --- setTimeout setTimeout(() =&gt; &#123; try &#123; //Promise/A+ 2.2.7.1 let x = onFulfilled(this.value); // x可能是一个proimise resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; //Promise/A+ 2.2.7.2 reject(e); &#125; &#125;, 0); &#125; if (this.status === REJECTED) &#123; //Promise/A+ 2.2.3 setTimeout(() =&gt; &#123; try &#123; let x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125; if (this.status === PENDING) &#123; this.onResolvedCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(this.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;); this.onRejectedCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;); &#125; &#125;); return promise2; &#125;&#125; 测试Promise是否符合规范 Promise/A+规范提供了一个专门的测试脚本，可以测试所编写的代码是否符合Promise/A+的规范。 首先在promise代码中加入如下代码: 1234567891011121314151617181920/** * Promise/A+规范测试 * 1.npm i -g promises-aplus-tests // 安装依赖 * 2.promises-aplus-tests Promise.js // promises-aplus-tests 执行当期promise文件 */Promise.deferred = function () &#123; // 延迟对象 let defer = &#123;&#125;; defer.promise = new Promise((resolve, reject) =&gt; &#123; defer.resolve = resolve; defer.reject = reject; &#125;); return defer;&#125;;try &#123; module.exports = Promise;&#125; catch (e) &#123;&#125; 完美通过测试的class版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156const PENDING = &#x27;PENDING&#x27;;const FULFILLED = &#x27;FULFILLED&#x27;;const REJECTED = &#x27;REJECTED&#x27;;const resolvePromise = (promise2, x, resolve, reject) =&gt; &#123; // 自己等待自己完成是错误的实现，用一个类型错误，结束掉 promise Promise/A+ 2.3.1 if (promise2 === x) &#123; return reject(new TypeError(&#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27;)) &#125; // Promise/A+ 2.3.3.3.3 只能调用一次 let called; // 后续的条件要严格判断 保证代码能和别的库一起使用 if ((typeof x === &#x27;object&#x27; &amp;&amp; x != null) || typeof x === &#x27;function&#x27;) &#123; try &#123; // 为了判断 resolve 过的就不用再 reject 了（比如 reject 和 resolve 同时调用的时候） Promise/A+ 2.3.3.1 let then = x.then; if (typeof then === &#x27;function&#x27;) &#123; // 不要写成 x.then，直接 then.call 就可以了 因为 x.then 会再次取值，Object.defineProperty Promise/A+ 2.3.3.3 then.call(x, y =&gt; &#123; // 根据 promise 的状态决定是成功还是失败 if (called) return; called = true; // 递归解析的过程（因为可能 promise 中还有 promise） Promise/A+ 2.3.3.3.1 resolvePromise(promise2, y, resolve, reject); &#125;, r =&gt; &#123; // 只要失败就失败 Promise/A+ 2.3.3.3.2 if (called) return; called = true; reject(r); &#125;); &#125; else &#123; // 如果 x.then 是个普通值就直接返回 resolve 作为结果 Promise/A+ 2.3.3.4 resolve(x); &#125; &#125; catch (e) &#123; // Promise/A+ 2.3.3.2 if (called) return; called = true; reject(e) &#125; &#125; else &#123; // 如果 x 是个普通值就直接返回 resolve 作为结果 Promise/A+ 2.3.4 resolve(x) &#125;&#125;class Promise &#123; constructor(executor) &#123; this.status = PENDING; this.value = undefined; this.reason = undefined; this.onResolvedCallbacks = []; this.onRejectedCallbacks= []; let resolve = (value) =&gt; &#123; if(this.status === PENDING) &#123; this.status = FULFILLED; this.value = value; this.onResolvedCallbacks.forEach(fn=&gt;fn()); &#125; &#125; let reject = (reason) =&gt; &#123; if(this.status === PENDING) &#123; this.status = REJECTED; this.reason = reason; this.onRejectedCallbacks.forEach(fn=&gt;fn()); &#125; &#125; try &#123; executor(resolve,reject) &#125; catch (error) &#123; reject(error) &#125; &#125; then(onFulfilled, onRejected) &#123; //解决 onFufilled，onRejected 没有传值的问题 //Promise/A+ 2.2.1 / Promise/A+ 2.2.5 / Promise/A+ 2.2.7.3 / Promise/A+ 2.2.7.4 onFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : v =&gt; v; //因为错误的值要让后面访问到，所以这里也要跑出个错误，不然会在之后 then 的 resolve 中捕获 onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : err =&gt; &#123; throw err &#125;; // 每次调用 then 都返回一个新的 promise Promise/A+ 2.2.7 let promise2 = new Promise((resolve, reject) =&gt; &#123; if (this.status === FULFILLED) &#123; //Promise/A+ 2.2.2 //Promise/A+ 2.2.4 --- setTimeout setTimeout(() =&gt; &#123; try &#123; //Promise/A+ 2.2.7.1 let x = onFulfilled(this.value); // x可能是一个proimise resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; //Promise/A+ 2.2.7.2 reject(e) &#125; &#125;, 0); &#125; if (this.status === REJECTED) &#123; //Promise/A+ 2.2.3 setTimeout(() =&gt; &#123; try &#123; let x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e) &#125; &#125;, 0); &#125; if (this.status === PENDING) &#123; this.onResolvedCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(this.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e) &#125; &#125;, 0); &#125;); this.onRejectedCallbacks.push(()=&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;, 0); &#125;); &#125; &#125;); return promise2; &#125;&#125;Promise.deferred = function () &#123; // 延迟对象 let defer = &#123;&#125;; defer.promise = new Promise((resolve, reject) =&gt; &#123; defer.resolve = resolve; defer.reject = reject; &#125;); return defer;&#125;;try &#123; module.exports = Promise;&#125; catch (e) &#123;&#125;","categories":[{"name":"JS进阶","slug":"JS进阶","permalink":"http://example.com/categories/JS%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"}]},{"title":"nginx+docker+jenkins自动化构建部署前端项目","slug":"nginx+docker+jenkins自动化构建部署前端项目","date":"2021-11-07T16:00:00.000Z","updated":"2021-11-10T03:40:45.081Z","comments":true,"path":"2021/11/08/nginx+docker+jenkins自动化构建部署前端项目/","link":"","permalink":"http://example.com/2021/11/08/nginx+docker+jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E9%83%A8%E7%BD%B2%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"双十一搞活动买了一个服务器，正好也借此来学习学习一个项目如何自动化构建部署前端项目。 实现目标：本地push代码到GitHub，Webhook自动触发jenkins上的构建动作,完成安装node插件并且打包自动部署到nginx服务器上。能立即看到页面效果 前置条件 github账号和项目 阿里云服务器 服务器安装nginx并且启动 服务器安装docker并且启动 docker安装jenkins并且启动 一、前置工作 登录服务器更新系统软件 1$ yum update 安装java和git 12$ yum install java$ yum install git 安装nginx 12$ yum install nginx$ service nginx start // 启动nginx服务 出现Redirecting to /bin/systemctl start nginx.service则说明nginx安装成功了，访问http://你的公网ip/ (nginx默认启动的是80端口，所以可以不需要修改),如果出现了nginx默认的欢迎画面则证明安装成功了。 安装docker 123curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun$ sudo systemctl start docker // 启动docker服务 docker安装最新jenkins镜像 1234docker pull jenkins/jenkins:lts//完成之后输入如下命令查看镜像docker images 123456789// 继续执行如下命令 创建一个容器。容器就是一台虚拟机// docker run -name [名称] 创建一个容器名称// -itd 表示后台运行// -v /home/react : /var/jenkins_home 将宿主机目录 跟 容器内目录做一个映射，// -p 8081:8080 jenkins/jenkins:lts 将宿主机端口跟容器端口做一个映射，使用安装的jenkins镜像docker run --name react_jenkins -itd -v /home/react:/var/jenkins_home -p 8080:8080 jenkins/jenkins:lts// 可以通过 docker ps | grep【容器名】 来查看容器信息docker ps | grep react_jenkins 浏览器输入ip:8080即可进入jenkins工作台 二、配置jenkins 第一步会让输入jenkins管理员密码，因为我们是容器内安装的jenkins，所以我们要进入到容器内部，查看jenkins密码 1docker exec -it react_jenkins /bin/bash 出现了如下画面jenkins开头的就说明进入了容器内部： 根据网页中提示找到密码输入后，使用推荐安装就行了 安装Node插件并配置Node 因为我们的项目是要用到node打包的，所以先在jenkins中安装nodeJs插件，安装后进入全局工具配置，配置一个我们要用到的node版本。（因为create-react-app创建的react的项目使用最新的node版本会报错，所以选择14.15.0版本） JDK&amp;GIT安装（选择自动安装）：自动安装JDK需要oracle账号，可以自行注册 系统配置GitHub服务器 ​ 这里有两点需要注意，这里的github服务器凭据需要选择Secret text，并把github的个人设置中找到Developer settings中找到Personal access tokens 填入其中，在点击连接测试，出现了Credentials verified for user xxxx则证明配置成功了 3、勾选管理hook并再第4步中复制hook链接粘贴到项目的webhook中 新建一个任务,按步骤操作即可 接下来再按步骤配置好任务的源码地址，构建触发器选择hook，构建环境选择Node，构建选择执行shell命令 三、修改nginx配置 修改nginx.conf配置目录到打包后的路径(路径为宿主服务器的映射目录就行了，因为容器映射到了宿主机的目录，打包后的产出都在那) 1/home/react/workspace/react_demo/build/ 四、验证效果 用create-react-app脚手架创建一个react项目，修改内部push到github仓库 可以通过Github hook log查看日志，看是否触发了webhook钩子 验证效果，完美~~ 五、问题总结 本次利用nginx+docker+jenkins做的自动化构建部署前端项目比较简单，适合个人使用，如果是公司的自动化构建部署会涉及到增量编译构建，不需要每次都yarn生成node_modules，依赖不变可以做一个缓存使用，加快构建速度，还会将构建产出做个转移发布，我在这里直接用nginx部署了build目录等待。自动化构建部署仍然需要深入学习。加油💪🏻 在docker创建容器的时候，映射了宿主机：容器目录，但是构建完成之后，宿主机目录没有构建后的产出，需要在宿主机的映射目录修改权限 1sudo chown -R 1000 【目录】 一开始给容器映射的端口号是8081:8080，如果要修改端口映射，需要修改docker容器的hostconfig.json，并且要先停止容器、停止docker服务 12345678910111213cd /var/lib/docker/containers/d00254ce3af7* #这里是CONTAINER IDvim hostconfig.json #修改hostconfig文件#如果之前没有端口映射, 应该有这样的一段:&quot;PortBindings&quot;:&#123;&#125; #增加一个映射, 这样写:&quot;PortBindings&quot;:&#123;&quot;8080/tcp&quot;:[&#123;&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;8080&quot;&#125;]&#125;#前一个数字是容器端口, 后一个是宿主机端口。将宿主机的8080端口映射到容器的8080端口#而修改现有端口映射更简单, 把端口号改掉就行。 命令的不熟悉，以及命令含义不熟悉，多百度多动手尝试，可以用到的一些命令 12345678910111213141516171819202122232425262728293031Docker 命令Lunix删除文件夹命令： rm -rf 【文件夹名称】启动启动docker容器：docker start 【容器id】查看信息查看所有docker镜像: docker images查看镜像信息： docker logs -f 【容器名】查看容器服务: docker ps | grep 【容器名】查看docker启动容器：docker ps -a 查看所有容器进入docker容器内部：docker exec -it 【容器名】 /bin/bash ——&gt; docker exec -it react_jenkins /bin/bash退出容器命令： exit删除删除容器： docker rm 【容器id】","categories":[{"name":"项目部署","slug":"项目部署","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"项目相关","slug":"项目相关","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/"}]},{"title":"React知识链路总结-下","slug":"React知识链路总结下","date":"2021-09-28T16:00:00.000Z","updated":"2022-01-14T02:37:18.351Z","comments":true,"path":"2021/09/29/React知识链路总结下/","link":"","permalink":"http://example.com/2021/09/29/React%E7%9F%A5%E8%AF%86%E9%93%BE%E8%B7%AF%E6%80%BB%E7%BB%93%E4%B8%8B/","excerpt":"","text":"React15的栈调和 架构 Reconciler（协调器）—— 负责找出变化的组件； Renderer（渲染器）—— 负责将变化的组件渲染到页面上； 调和过程和Diff算法Virtual DOM 是一种编程概念，在这个概念里，UI是一个种理想化的，或者说虚拟的表现形式被保存在内存中，并通过ReactDOM等类库使之与真实DOM同步，这一过程叫协调（调和）：即将虚拟DOM映射成真实DOM的过程 调和是使一致的过程：包括组件的挂载、卸载、更新等过程 Diff是找不同的过程 Diff算法的设计思想想要找出两个树结构之间的不同，传统的计算方法是通过循环递归进行树节点的一一对比，复杂度为O(n^3) 若两个组件属于同一个类型，他们将拥有相同的DOM树结构 处于同一层级的一组子节点，可用通过设置key作为唯一标识从而维持在渲染过程中的稳定性 key属性帮助React记住节点以便重用 解读setState工作流 在React钩子函数及合成事件中，它表现为异步 在setTimeout、setInterval等函数中包括DOM原生事件中，它表现为同步 123456789101112131415//伪代码isBatchingUpdates = true; this.setState(&#123; // 同步执行，异步更新 count: this.state.count+1&#125;)isBatchingUpdates = false isBatchingUpdates = true ；setTimeout(()=&gt;&#123; // 异步执行，同步更新 this.setState(&#123; count:this.state.count+1 &#125;)&#125;)isBatchingUpdates = false; React 16的Fiber架构 架构 Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler； Reconciler（协调器）—— 负责找出变化的组件：更新工作从递归变成了可以中断的循环过程。Reconciler内部采用了Fiber的架构； Renderer（渲染器）—— 负责将变化的组件渲染到页面上。 Fiber架构的迭代动机和设计思想 Stack reconciler的局限性 Reconciler采用递归的方式创建虚拟DOM，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，递归更新时间超过了16ms，用户交互就会卡顿 Fiber如何解决问题 实现增量渲染：将一个渲染任务拆解成多个渲染任务 核心：可中断、可恢复与优先级；一下分别是React15与React16的核心实现 Fiber架构下ReactDOM.render的渲染链路","categories":[{"name":"框架-React","slug":"框架-React","permalink":"http://example.com/categories/%E6%A1%86%E6%9E%B6-React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"数据结构--树","slug":"数据结构----树","date":"2021-09-28T16:00:00.000Z","updated":"2021-10-22T08:50:55.968Z","comments":true,"path":"2021/09/29/数据结构----树/","link":"","permalink":"http://example.com/2021/09/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84----%E6%A0%91/","excerpt":"","text":"数据结构之树 树的优点 查找效率要比数组、链表高 模拟场景方便，因为树是非线性的数据结构 可以表示一对多比如文档的目录结构 树的术语 节点的度： 节点的子树个数 树的度： 树的所有节点中最大的度数 叶节点： 度为0的节点 树的深度： 树中所有节点中最大层次是这棵树的深度 二叉树 如果树中的每个节点中最多只能有两个子节点，这样的树就叫做二叉树； 二叉树可以为空，也就是没有节点，若不为空，则它是由根节点和称为其左子树TL和右子树TR两个不相交的二叉树组成 二叉树比较重要的特性 一个二叉树第i层的最大节点数为：2^(i-1) (i&gt;=1) 深度为K的二叉树最大节点总数为：2^k - 1 (k&gt;=1) 二叉树的存储 二叉树最常见的存储方式时使用链表，将每个节点封装成一个数据Node，Node中包含存储的数据，左节点的引用，右节点的引用 二叉搜索树(BST,Binary Search Tree) 特征 二叉搜索树是一颗二叉树，可以为空； 如果不为空则满足下面性质： 非空左子树的所有键值小于其根节点的键值 非空右子树的所有键值大于其根节点的键值 左右子树本身也是二叉搜索树 特点 二叉搜索树的特点就是相对较小的值总保存在左节点上，利用这一特点查找效率非常高 利用二分查找的思想 树的遍历 先序遍历 先访问根节点 先序遍历其左子树 先序遍历其右子树 中序遍历 中序遍历其左子树 访问根节点 中序遍历其右子树 后序遍历 后序遍历其左子树 后序遍历其右子树 访问根节点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166/* * @Author: QWB &lt;wenbinqiu42@gmail.com&gt; * @Date: 2021-10-18 17:54:36 * @LastEditors: QWB * @LastEditTime: 2021-10-21 20:44:03 * @Description: 二叉树和二叉查找树 */class Node &#123; constructor(key) &#123; this.key = key; this.left = null; this.right = null; &#125;&#125;class BinarySearchTree &#123; constructor() &#123; this.root = null; // 属性 &#125; // 插入 insert(key) &#123; let newNode = new Node(key); // 判断是否有根节点 if (this.root === null) &#123; this.root = newNode; &#125; else &#123; this.insertNode(this.root, newNode); // 递归比较 &#125; &#125; insertNode(node, newNode) &#123; // TODO: 左子树查找 if (newNode.key &lt; node.key) &#123; if (node.left === null) &#123; // 如果左子节点为空，插入的节点就为左子节点 node.left = newNode; &#125; else &#123; // 如果左子节点不为空，递归比较左子节点和插入节点 this.insertNode(node.left, newNode); &#125; &#125; else &#123; // TODO:右子树查找 if (node.right === null) &#123; node.right = newNode; &#125; else &#123; this.insertNode(node.right, newNode); &#125; &#125; &#125; // 先序遍历 preOrderTraversal(handler) &#123; // 先遍历根节点,递归调用 this.preOrderTraversalNode(this.root, handler); &#125; preOrderTraversalNode(node, handler) &#123; if (node !== null) &#123; // 利用handler来处理key handler(node.key); // 处理经过节点的左子节点 this.preOrderTraversalNode(node.left, handler); // 处理经过节点的右子节点 this.preOrderTraversalNode(node.right, handler); &#125; &#125; // 中序遍历 midOrderTraversal(handler) &#123; this.midOrderTraversalNode(this.root, handler); &#125; midOrderTraversalNode(node, handler) &#123; if (node !== null) &#123; // 处理左子树中的节点 this.midOrderTraversalNode(node.left, handler); // 处理节点 handler(node.key); // 处理右子树中的节点 this.midOrderTraversalNode(node.right, handler); &#125; &#125; // 后序遍历 postOrderTraversal(handler) &#123; this.postOrderTraversalNode(this.root, handler); &#125; postOrderTraversalNode(node, handler) &#123; if (node !== null) &#123; // 处理左子树中的节点 this.midOrderTraversalNode(node.left, handler); // 处理右子树中的节点 this.midOrderTraversalNode(node.right, handler); // 处理节点 handler(node.key); &#125; &#125; // 最小值 ，根据二叉搜索树的特性，最左端的子节点 就是最小值 min() &#123; let node = this.root; while (node.left !== null) &#123; node = node.left; &#125; return node.key; &#125; // 最大值，根据二叉搜索树的特性。最右端子节点就是最大值 max() &#123; let node = this.root; while (node.right !== null) &#123; node = node.right; &#125; return node.key; &#125; //搜索 找到了则返回true,没找到则返回false search(key) &#123; // 获取根节点 let node = this.root; while (node !== null) &#123; if (key &lt; node.key) &#123; // 在左子树中寻找 node = node.left; &#125; else if (key &gt; node.key) &#123; // 在右子树中寻找 node = node.right; &#125; else &#123; return true; &#125; &#125; // while 之外没找到 return false; &#125;&#125;// testlet bst = new BinarySearchTree();bst.insert(11);bst.insert(7);bst.insert(15);bst.insert(5);bst.insert(3);bst.insert(9);bst.insert(8);bst.insert(10);bst.insert(13);bst.insert(12);bst.insert(14);bst.insert(20);bst.insert(18);bst.insert(25);console.log(bst);console.log(bst.max());console.log(bst.search(18))console.log(bst.search(20))console.log(bst.search(2))// let resultString = &#x27;&#x27;;// bst.preOrderTraversal((key) =&gt; &#123;// resultString += key + &#x27;--&#x27;;// &#125;);// alert(resultString);let resultString = &#x27;&#x27;;bst.midOrderTraversal((key) =&gt; &#123; resultString += key + &#x27; &#x27;;&#125;);alert(resultString);","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"React知识链路总结-上","slug":"React知识链路总结上","date":"2021-09-27T16:00:00.000Z","updated":"2022-01-14T02:16:35.718Z","comments":true,"path":"2021/09/28/React知识链路总结上/","link":"","permalink":"http://example.com/2021/09/28/React%E7%9F%A5%E8%AF%86%E9%93%BE%E8%B7%AF%E6%80%BB%E7%BB%93%E4%B8%8A/","excerpt":"","text":"JSX如何变成DOM的 1.JSX的本质是什么，它和JS之间到底是什么关系 2.为什么要用JSX？不用会怎么样？ 3.JSX背后的功能模块是什么，这个功能模块都做了那些事情？ JSX是JavaScript的一种语法扩展，它和模板语言很接近，但是它充分具备JavaScript的能力 JSX语法是如何在Javascript中生效的？ JSX会被Babel编译为React.createElement(),React.createElement()将返回一个ReactElement的JS对象 1234567891011121314151617181920212223242526272829303132333435/*type:用于表示节点的类型，可以是html标签，React组件类型config:以对象形式传入，组件所有的属性都会以键值对的形式存储在config对象中children:组件标签之间嵌套的内容*/export function createElement(type,config,children)//eg:&lt;ul className=&quot;list&quot;&gt; &lt;li key=&#x27;1&#x27;&gt;1&lt;/li&gt; &lt;li key=&#x27;2&#x27;&gt;2&lt;/li&gt;&lt;/ul&gt;React.createElement( &#x27;ul&#x27;, &#123; className: &#x27;list&#x27;, &#125;, React.createElement( &#x27;li&#x27;, &#123; key: 1, &#125;, &#x27;1&#x27; ), React.createElement(&#x27;li&#x27;, &#123; key: 2 &#125;, &#x27;2&#x27;));ReactDOM.render(//需要渲染的元素(ReactElement). element, //元素挂载的目标容器（一个真实DOM） container, //回调函数 [callback]) 源码 关键是React中的ReactElement.js中的三个函数 createElement：创建并返回给定类型的新 ReactElement ReactElement： 创建一个新的ReactElement isValidElement：验证对象是否是一个 ReactElement。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163/** * Create and return a new ReactElement of the given type. * 创建并返回给定类型的新 ReactElement。 * See https://reactjs.org/docs/react-api.html#createelement */export function createElement(type, config, children) &#123; let propName; // Reserved names are extracted const props = &#123;&#125;; let key = null; let ref = null; let self = null; let source = null; if (config != null) &#123; // 处理config，然后赋值给props if (hasValidRef(config)) &#123; ref = config.ref; &#125; if (hasValidKey(config)) &#123; key = &#x27;&#x27; + config.key; &#125; self = config.__self === undefined ? null : config.__self; source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object for (propName in config) &#123; if ( hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName) ) &#123; props[propName] = config[propName]; &#125; &#125; &#125; // Children can be more than one argument, and those are transferred onto // the newly allocated props object. // 处理children 会被赋值给props.children const childrenLength = arguments.length - 2; if (childrenLength === 1) &#123; props.children = children; &#125; else if (childrenLength &gt; 1) &#123; const childArray = Array(childrenLength); for (let i = 0; i &lt; childrenLength; i++) &#123; childArray[i] = arguments[i + 2]; &#125; if (__DEV__) &#123; if (Object.freeze) &#123; Object.freeze(childArray); &#125; &#125; props.children = childArray; &#125; // Resolve default props // 处理defaultProps if (type &amp;&amp; type.defaultProps) &#123; const defaultProps = type.defaultProps; for (propName in defaultProps) &#123; if (props[propName] === undefined) &#123; props[propName] = defaultProps[propName]; &#125; &#125; &#125; if (__DEV__) &#123; if (key || ref) &#123; const displayName = typeof type === &#x27;function&#x27; ? type.displayName || type.name || &#x27;Unknown&#x27; : type; if (key) &#123; defineKeyPropWarningGetter(props, displayName); &#125; if (ref) &#123; defineRefPropWarningGetter(props, displayName); &#125; &#125; &#125; // 传递给ReactElement return ReactElement( type, key, ref, self, source, ReactCurrentOwner.current, props, );&#125;const ReactElement = function(type, key, ref, self, source, owner, props) &#123; const element = &#123; // This tag allows us to uniquely identify this as a React Element // 标记这是一个React Element，是一个唯一标识；如果恶意插入标签可以用这个来区分是什么类型，这算是React为安全考虑的一个点 $$typeof: REACT_ELEMENT_TYPE, // Built-in properties that belong on the element // 属于元素的内部属性 type: type, key: key, ref: ref, props: props, // Record the component responsible for creating this element. _owner: owner, &#125;; if (__DEV__) &#123; // The validation flag is currently mutative. We put it on // an external backing store so that we can freeze the whole object. // This can be replaced with a WeakMap once they are implemented in // commonly used development environments. element._store = &#123;&#125;; // To make comparing ReactElements easier for testing purposes, we make // the validation flag non-enumerable (where possible, which should // include every environment we run tests in), so the test framework // ignores it. Object.defineProperty(element._store, &#x27;validated&#x27;, &#123; configurable: false, enumerable: false, writable: true, value: false, &#125;); // self and source are DEV only properties. Object.defineProperty(element, &#x27;_self&#x27;, &#123; configurable: false, enumerable: false, writable: false, value: self, &#125;); // Two elements created in two different places should be considered // equal for testing purposes and therefore we hide it from enumeration. Object.defineProperty(element, &#x27;_source&#x27;, &#123; configurable: false, enumerable: false, writable: false, value: source, &#125;); if (Object.freeze) &#123; Object.freeze(element.props); Object.freeze(element); &#125; &#125; // 返回元素 return element;&#125;;/*React提供的一个全局方法，用来判断是否是一个ReactElement*/export function isValidElement(object) &#123; return ( typeof object === &#x27;object&#x27; &amp;&amp; object !== null &amp;&amp; object.$$typeof === REACT_ELEMENT_TYPE );&#125; React Component 在React中我们经常创建Class组件和Function组件 基本使用 1234567891011121314class AppClass extends React.Component &#123; render() &#123; return &lt;p&gt;Findly&lt;/p&gt; &#125;&#125;console.log(&#x27;这是ClassComponent：&#x27;, AppClass);console.log(&#x27;这是Element：&#x27;, &lt;AppClass/&gt;);function AppFunc() &#123; return &lt;p&gt;Findly&lt;/p&gt;;&#125;console.log(&#x27;这是FunctionComponent：&#x27;, AppFunc);console.log(&#x27;这是Element：&#x27;, &lt;AppFunc/&gt;); 从结果来看，他们的type都是它们自身，classComponent为AppClass,FunctionComponent为AppFunc 注意:heavy_exclamation_mark: AppClass instanceof Function === true; AppFunc instanceof Function === true; 所以无法通过引用类型区分它们是哪种Component，React通过使用ClassComponent.prototype.isReactComponent来判断是否为ClassComponent 源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function Component(props, context, updater) &#123; this.props = props; this.context = context; // 如果一个组件有字符串参数，将分配一个不同的对象。 this.refs = emptyObject; // update更新组件，updater是react-dom中的内容 this.updater = updater || ReactNoopUpdateQueue;&#125;// 判断是否为classComponentComponent.prototype.isReactComponent = &#123;&#125;;Component.prototype.setState = function(partialState, callback) &#123; invariant( typeof partialState === &#x27;object&#x27; || typeof partialState === &#x27;function&#x27; || partialState == null, &#x27;setState(...): takes an object of state variables to update or a &#x27; + &#x27;function which returns an object of state variables.&#x27;, ); this.updater.enqueueSetState(this, partialState, callback, &#x27;setState&#x27;);&#125;;Component.prototype.forceUpdate = function(callback) &#123; this.updater.enqueueForceUpdate(this, callback, &#x27;forceUpdate&#x27;);&#125;;//PureComponentfunction ComponentDummy() &#123;&#125;ComponentDummy.prototype = Component.prototype;function PureComponent(props, context, updater) &#123; this.props = props; this.context = context; this.refs = emptyObject; this.updater = updater || ReactNoopUpdateQueue;&#125;// PureComponent继承自Componentconst pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());pureComponentPrototype.constructor = PureComponent;// Avoid an extra prototype jump for these methods.Object.assign(pureComponentPrototype, Component.prototype);//isPureReactComponent标识是一个PureComponent组件pureComponentPrototype.isPureReactComponent = true; 组件生命周期 拆解React生命周期，从React15开始 constructor(props) 仅在挂载的时候调用一次，可以在里面初始化state componentWillMount 仅在挂载的时候调用一次；会在执行render()方法前触发 render render()在执行过程中并不会操作真实的DOM，它的职能是把需要渲染的内容返回出来 componentDidMount 仅在挂载的时候调用一次,DOM已经挂载到页面上，可以在这个生命周期执行真实DOM相关的操作 componentReceiveProps并不是由props的变化触发的，而是由父组件的更新触发的 在父组件修改仅跟父组件有关的state，传递给子组件的props没有改变，但是任然会触发componentReceiveProps方法 shouldComponentUpdate（nextProps,nextState） 控制组件re-render，可用于性能优化避免不必要的render componentWillUpdate render() componentDidUpdate componentWillUnmount 组件在父组件中被移除了 组件中设置了key属性，父组件在render过程中，发现key值和上一次不一致 React16生命周期 getDerivedStateFromProps（props，state）替代了componentWillMount 此方法作为一个静态方法,在方法内部获取不到组件实例this，还需要一个对象格式的返回值，因为React需要将此对象作为当前组件的state getDerivedStateFromProps有且仅有一个用途：使用props来派生/更新state 此生命周期在挂载和更新都会触发：因为派生state不仅在初始化props存在，在更新时也会存在 为什么要用getDerivedStateFromProps代替componentWillReceiveProps getDerivedStateFromProps与componentDidUpdate一起，涵盖了过时的componentWillReceiveProps的所有用例 React16为什么改变生命周期 Fiber是React16对React核心算法的一次重写 Fiber会使原本同步的渲染过程变成异步的 在React16之前，每次触发组件更新，React都会构建一棵虚拟的DOM树，递归的diff比较当前页面的DOM树（不可打断的更新过程），同步渲染开始就会占据主线程，导致页面不可渲染无法交互出现卡死现象 Fiber 会将一个大的更新任务拆解成为许多小任务，每当小任务的更新完成之后会将主线程交回给渲染线程，避免卡顿的现象 Fibel做到了任务拆解以及可打断使得同步渲染变成异步渲染 Fibel架构的重要特征就是可以被打断的异步渲染模式 根据能否被打断将React16的生命周期划分为了render和commit两个阶段 render阶段在执行过程中允许被打断和重启，而commit阶段则总是同步执行的 因为render是在用户不可见的情况下发生的，就算打断、重启，用户也是不知道的 为什么废弃componentWillxxx这些生命周期，因为它们在Fibel的架构下是可以打断、重启的；例如在这个生命周期中发起了付款请求，可能会发起多个请求 commit阶段则是真实DOM的渲染，所以要同步进行 数据如何在组件间流动 单向数据流动props 父传子通过props的形式传递数据 子传父通过将数据入参到父组件传递的函数，触发父组件的函数调用 兄弟组件通信借助父组件这个公共组件进行通信，将兄弟组件通信转换为了父子组件通信 不推荐使用props解决其他场景的需求 组件层级嵌套过深，根组件与末子组件进行通信需要层层传递props,造成中间组件的代码污染，维护成本增加 利用发布-订阅模式驱动数据流 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/* * @Author: QWB &lt;wenbinqiu42@gmail.com&gt; * @Date: 2021-10-14 21:55:18 * @LastEditors: QWB * @LastEditTime: 2021-10-14 22:14:15 * @Description: */class MyEventEmitter &#123; constructor() &#123; // eventMap 用来存储事件和监听函数之间的关系 this.eventMap = &#123;&#125;; &#125; // type代表事件名称 on(type, handler) &#123; // handler必须是一个函数,如果不是直接报错 if (!(handler instanceof Function)) &#123; throw new Error(&#x27;请传入一个函数&#x27;); &#125; // 判断type事件对应的队列是否存在 if (!this.eventMap[type]) &#123; this.eventMap[type] = []; &#125; // 如果存在 则直接让队列中推入handler this.eventMap[type].push(handler); &#125; // emit触发事件,params为传递的参数 emit(type, params) &#123; // 如果存在对应的事件队列 if (this.eventMap[type]) &#123; // 一次执行对应事件队列中的handler this.eventMap[type].forEach((handler, index) =&gt; &#123; // 传参params handler(params); &#125;); &#125; &#125; // 清除对应事件队列 off(type, handler) &#123; if (this.eventMap[type]) &#123; this.eventMap[type].splice(this.eventMap[type].indexOf(handler) &gt;&gt;&gt; 0, 1); &#125; &#125;&#125;const myEvent = new MyEventEmitter();const testHandler = function (params) &#123; console.log(`test事件触发了,testHandler接收到的参数是$&#123;params&#125;`);&#125;;myEvent.on(&#x27;test&#x27;, testHandler);myEvent.emit(&#x27;test&#x27;, &#x27;newState&#x27;);// 伪代码// 将myEvent挂载到globalconst globalEvent = window.myEvent;class B extends React.Component &#123; // ... state = &#123; newParams: &#x27;&#x27;, &#125;; handler = (params) =&gt; &#123; this.setState(&#123; newParams: params, &#125;); &#125;; bindHandler = () =&gt; &#123; globalEvent.on(&#x27;someEvent&#x27;, this.handle); &#125;; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.bindHandler&#125;&gt;点我监听A的动作&lt;/button&gt; &lt;div&gt;A传入的内容是&#123;this.state.newParams&#125;&lt;/div&gt; &lt;/div&gt; ); &#125;&#125;class A extends React.Component &#123; state = &#123; infoToB: &#x27;哈哈哈哈我来自A&#x27;, &#125;; reportToB = () =&gt; &#123; globalEvent.emit(&#x27;someEvent&#x27;, this.state.infoToB); &#125;; render() &#123; return &lt;button onClick=&#123;this.reportToB&#125;&gt;点我把state传递给B&lt;/button&gt;; &#125;&#125; 使用Context API维护全局状态 Redux 应用复杂度不断提升，组件间的关系难以处理，可以借助Redux提供可预测的状态管理 组成 store是一个单一的数据源，而且是只读的 action是对变化的描述 reducer根据变化描述进行分发和处理返回新的state 1234567891011121314151617181920// 引入reduximport &#123;createStore&#125; from &#x27;redux&#x27;;// 创建storeconst store = createStore( reducer, initialValue, applyMiddleware(middlewre1,middleware2...))// 使用dispatch派发action，action会进入到reducer里触发对应的更新store.dispatch(action)// reducer的作用是将新的state返回给store,纯函数const reducer = (state,action)=&gt;&#123; // 对state做逻辑处理 return newState&#125; React-hooks的设计动机与工作模式 hooks出现之前，类组件与函数式组件的区别 类组件需要继承Class，函数组件不需要 类组件可以访问生命周期方法，函数组件不能 类组件可以获取到实例化后的this 并且基于this做各种不同的操作，函数组件不能 函数组件可以定义state状态。函数组件不可以 重新认识类组件 类组件是面向对象编程的一种表现 封装：将一类属性和方法，封装在一个Class中去 继承：新的Class可以通过继承现有Class实现对某一类属性和方法的复用 函数组件 函数组件会捕获render内部的状态，这是两类组件最大的不同 函数组件与类组件本质的差别是心智模式层面的差异，是面向对象编程和函数式编程的不同设计思想；函数组件更加契合React框架的设计理念：UI=f(data) 123456789101112131415// 类组件class App extends React.Component&#123; // 虽然props本身是不可变的，但是this确实可变的，this上的数据是可以修改的，this.props的调用每次都会获取最新的props，这是React确保数据实时性的重要手段 showMessage = ()=&gt;&#123; alert(&#x27;followed&#x27;+this.props.user) &#125; handleClick = ()=&gt;&#123; setTimeout(this.showMessage,3000) &#125; render()&#123; return &lt;button onClick=&#123;this.handleClick &#125;&gt;Follow&lt;/button&gt; &#125;&#125; useEffect不同情况下的不同使用 每一次渲染都要执行的副作用：传入回调函数，不传依赖数组 1useEffect(callBack) 仅在挂载阶段执行一次的副作用，传入回调函数，同时传入一个空数组 1useEffect(callBack,[]) 仅在挂载阶段和卸载阶段执行的副作用：传入一个函数，且函数的返回值是一个函数，同时传入一个空数组 123456useEffect(()=&gt;&#123; return ()=&gt;&#123; // return返回的是一个清除函数 &#125;&#125;,[]) 为什么需要React-Hooks 告别难以理解的Class 生命周期 this 解决业务逻辑难以拆分的问题 使状态逻辑复用变得简单可行 类组件实现复用靠的是HOC和Render Props设计模式，它们在实现逻辑复用的同时，也破坏了组件结构，最常见的一个问题是组件嵌套地狱现象 Hooks能够实现粒度更细的组件抽离，达到既不破坏组件结构又能实现逻辑复用的效果 函数组件从设计理念更契合React的理念 Hooks的局限性 hooks暂时还不能完全地为函数组件补齐类组件的能力 目前暂时还没有对应不常用的 getSnapshotBeforeUpdate，getDerivedStateFromError 和 componentDidCatch 生命周期的 Hook 等价写法 Hooks在使用层面有着更强的规则约束 React-Hooks的使用原则 只在React函数中调用Hook 不要在循环、条件或者嵌套函数中调用Hook hooks的正常运行，在底层依赖于顺序链表 以useState为例首次渲染和更新渲染 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 初始化statefunction mountState&lt;S&gt;( initialState: (() =&gt; S) | S,): [S, Dispatch&lt;BasicStateAction&lt;S&gt;&gt;] &#123; //定义一个hook，添加到hooks链表尾部 const hook = mountWorkInProgressHook(); // 如果初始值是一个函数，初始值为函数执行结果 if (typeof initialState === &#x27;function&#x27;) &#123; // $FlowFixMe: Flow doesn&#x27;t like mixed types initialState = initialState(); &#125; // 将当前初始值赋值给&#x27;记忆值&#x27; hook.memoizedState = hook.baseState = initialState; // 创建当前hook对象的更新队列，主要为了依序保留dispatch const queue = (hook.queue = &#123; pending: null, interleaved: null, lanes: NoLanes, dispatch: null, lastRenderedReducer: basicStateReducer, lastRenderedState: (initialState: any), &#125;); // dispatch是由上下文一个叫dispatchAction创建的 const dispatch: Dispatch&lt; BasicStateAction&lt;S&gt;, &gt; = (queue.dispatch = (dispatchAction.bind( null, currentlyRenderingFiber, queue, ): any)); // 返回目标数组，dispatch就是我们用到的setxxx这个函数 return [hook.memoizedState, dispatch];&#125;// hook生成function mountWorkInProgressHook(): Hook &#123; // 单个hook以对象的形式存在 const hook: Hook = &#123; memoizedState: null, // 记忆值 baseState: null, // 初始state baseQueue: null, // 初始队列 queue: null, // 当前队列 next: null, // next指针 &#125;; if (workInProgressHook === null) &#123; // This is the first hook in the list // 将hook作为链表的头节点处理 currentlyRenderingFiber.memoizedState = workInProgressHook = hook; &#125; else &#123; // Append to the end of the list // 如果链表不为空， 则将hook追加到链表尾部 workInProgressHook = workInProgressHook.next = hook; &#125; // 返回当前hook return workInProgressHook;&#125; updateState做的事情就是按顺序去遍历之前构建好的链表，取出对应的数据信息进行渲染； hooks的渲染是通过依次遍历来定位每个hooks内容，如果前后两次读到的链表在顺序上出现差异，那么渲染结果不可控","categories":[{"name":"框架-React","slug":"框架-React","permalink":"http://example.com/categories/%E6%A1%86%E6%9E%B6-React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"webpack性能优化之优化打包构建速度","slug":"webpack性能优化之优化打包构建速度","date":"2021-09-21T16:00:00.000Z","updated":"2021-11-10T05:47:30.296Z","comments":true,"path":"2021/09/22/webpack性能优化之优化打包构建速度/","link":"","permalink":"http://example.com/2021/09/22/webpack%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E4%BC%98%E5%8C%96%E6%89%93%E5%8C%85%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/","excerpt":"","text":"webpack性能优化之优化打包构建速度 优化打包的构建速度能够提高开发体验以及开发效率，比如：代码打包够快编译够快，自动刷新等等 优化babel-loader,使用babel-loader?cacheDirectory方式，开启缓存，在代码没有改变的情况下不会重新编译会缓存打包结果值 也可利用include和exclude来缩小需要编译的文件范围 利用IgnorePlugin来忽略一些不必要的打包目录 当使用moment进行时间格式化时，打包时会把locale内部的所有语言打包，可以通过配置IgnorePlugin来控制忽略掉这些目录123456789101112 plugins: [ //weback自带的插件 忽略moment的locale文件夹， new webpack.IgnorePlugin(/\\.\\/locale/,/moment/),// 如果引入这个moment包时 会忽略调 locale文件 new HtmlWebpackPlugin(&#123; template:&quot;./public/index.html&quot;, &#125;) ], //我们要手动引入需要的语言包// import &quot;moment/locale/zh-cn&quot;; 利用happyPack开启多进程打包 在webpack构建过程中，我们需要使用Loader对js，css，图片，字体等文件做转换操作，并且转换的文件数据量也是非常大的，且这些转换操作不能并发处理文件，而是需要一个个文件进行处理，HappyPack的基本原理是将这部分任务分解到多个子进程中去并行处理，子进程处理完成后把结果发送到主进程中，从而减少总的构建时间 123456789101112131415161718192021 module: &#123; rules: [ // js &#123; test: /\\.js$/, // 把对 .js 文件的处理转交给 id 为 babel 的 HappyPack 实例 use: [&#x27;happypack/loader?id=babel&#x27;], include: srcPath, // exclude: /node_modules/ &#125;, ], &#125;,plugins:[ // happyPack 开启多进程打包 new HappyPack(&#123; // 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件 id: &#x27;babel&#x27;, // 如何处理 .js 文件，用法和 Loader 配置中一样 loaders: [&#x27;babel-loader?cacheDirectory&#x27;], &#125;),] 利用ParallelUglifyPlugin开启多进程压缩JS(本质还是使用uglifyjs插件，但是开启了多进程打包)123456789101112131415161718192021plugins:[ // 使用 ParallelUglifyPlugin 并行压缩输出的 JS 代码 new ParallelUglifyPlugin(&#123; // 传递给 UglifyJS 的参数 // （还是使用 UglifyJS 压缩，只不过帮助开启了多进程） uglifyJS: &#123; output: &#123; beautify: false, // 最紧凑的输出 comments: false, // 删除所有的注释 &#125;, compress: &#123; // 删除所有的 `console` 语句，可以兼容ie浏览器 drop_console: true, // 内嵌定义了但是只用到一次的变量 collapse_vars: true, // 提取出出现多次但是没有定义成变量去引用的静态值 reduce_vars: true, &#125;, &#125;, &#125;),] 自动刷新 配置了devserver会自动开启自动刷新功能123456789101112131415161718192021devServer: &#123; port: 8080, progress: true, // 显示打包的进度条 contentBase: distPath, // 根目录 open: true, // 自动打开浏览器 compress: true, // 启动 gzip 压缩 hot: true, // 设置代理 proxy: &#123; // 将本地 /api/xxx 代理到 localhost:3000/api/xxx &#x27;/api&#x27;: &#x27;http://localhost:3000&#x27;, // 将本地 /api2/xxx 代理到 localhost:3000/xxx &#x27;/api2&#x27;: &#123; target: &#x27;http://localhost:3000&#x27;, pathRewrite: &#123; &#x27;/api2&#x27;: &#x27;&#x27; &#125; &#125; &#125; &#125;, 利用HotModuleReplacementPlugin开启热更新 使用webpack自带的HotModuleReplacementPlugin插件，在devServer配置中也要加入hot,hotOnly属性配置12345678910111213141516171819202122232425262728293031// const HotModuleReplacementPlugin = require(&#x27;webpack/lib/HotModuleReplacementPlugin&#x27;); plugins: [ new webpack.DefinePlugin(&#123; // window.ENV = &#x27;production&#x27; ENV: JSON.stringify(&#x27;development&#x27;) &#125;), new HotModuleReplacementPlugin() ],devServer: &#123; port: 8080, progress: true, // 显示打包的进度条 contentBase: distPath, // 根目录 open: true, // 自动打开浏览器 compress: true, // 启动 gzip 压缩 hot: true, // 开启热更新 hotOnly:true, // 开启热更新失败也不自动刷新 // 设置代理 proxy: &#123; // 将本地 /api/xxx 代理到 localhost:3000/api/xxx &#x27;/api&#x27;: &#x27;http://localhost:3000&#x27;, // 将本地 /api2/xxx 代理到 localhost:3000/xxx &#x27;/api2&#x27;: &#123; target: &#x27;http://localhost:3000&#x27;, pathRewrite: &#123; &#x27;/api2&#x27;: &#x27;&#x27; &#125; &#125; &#125; &#125;, 对于文件还需要使用module.hot.accept做变化处理12345678910111213141516171819202122232425262728// 引入 cssimport &#x27;./style/style1.css&#x27;;import &#x27;./style/style2.less&#x27;;import &#123; sum &#125; from &#x27;./math&#x27;;import _ from &#x27;lodash&#x27;;const sumRes = sum(10, 20);console.log(&#x27;sumRes&#x27;, sumRes);// 引入图片function insetImg(imgFile) &#123; const img = new Image(); img.src = imgFile; document.body.appendChild(img);&#125;import imageFile1 from &#x27;./img/1.png&#x27;;insetImg(imageFile1);import imageFile2 from &#x27;./img/2.jpeg&#x27;;insetImg(imageFile2);// 增加，开启热更新之后的代码逻辑if (module.hot) &#123; module.hot.accept([&#x27;./math&#x27;], () =&gt; &#123; const sumRes = sum(10, 30) console.log(&#x27;sumRes in hot&#x27;, sumRes) &#125;)&#125; DLLPlugin针对第三方库做提前打包，避免反复编译浪费时间 前端框架体积大，构建慢，而且是稳定的版本所以同一八本只需要构建一次不用重复构建，节省打包时间12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const path = require(&#x27;path&#x27;)const webpack = require(&#x27;webpack&#x27;)const &#123; smart &#125; = require(&#x27;webpack-merge&#x27;)const webpackCommonConf = require(&#x27;./webpack.common.js&#x27;)const &#123; srcPath, distPath &#125; = require(&#x27;./paths&#x27;)// 第一，引入 DllReferencePluginconst DllReferencePlugin = require(&#x27;webpack/lib/DllReferencePlugin&#x27;);module.exports = smart(webpackCommonConf, &#123; mode: &#x27;development&#x27;, module: &#123; rules: [ &#123; test: /\\.js$/, loader: [&#x27;babel-loader&#x27;], include: srcPath, exclude: /node_modules/ // 第二，不要再转换 node_modules 的代码 &#125;, ] &#125;, plugins: [ new webpack.DefinePlugin(&#123; // window.ENV = &#x27;production&#x27; ENV: JSON.stringify(&#x27;development&#x27;) &#125;), // 第三，告诉 Webpack 使用了哪些动态链接库 new DllReferencePlugin(&#123; // 描述 react 动态链接库的文件内容 manifest: require(path.join(distPath, &#x27;react.manifest.json&#x27;)), &#125;), ], devServer: &#123; port: 8080, progress: true, // 显示打包的进度条 contentBase: distPath, // 根目录 open: true, // 自动打开浏览器 compress: true, // 启动 gzip 压缩 // 设置代理 proxy: &#123; // 将本地 /api/xxx 代理到 localhost:3000/api/xxx &#x27;/api&#x27;: &#x27;http://localhost:3000&#x27;, // 将本地 /api2/xxx 代理到 localhost:3000/xxx &#x27;/api2&#x27;: &#123; target: &#x27;http://localhost:3000&#x27;, pathRewrite: &#123; &#x27;/api2&#x27;: &#x27;&#x27; &#125; &#125; &#125; &#125;&#125;) 经过配置的打包产物如下： 在index.html页面中要使用产出的dll.js文件 最后在webpack.dev.js中告诉DllReferencePlugin使用哪些动态链接库1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const path = require(&#x27;path&#x27;)const webpack = require(&#x27;webpack&#x27;)const &#123; smart &#125; = require(&#x27;webpack-merge&#x27;)const webpackCommonConf = require(&#x27;./webpack.common.js&#x27;)const &#123; srcPath, distPath &#125; = require(&#x27;./paths&#x27;)// 第一，引入 DllReferencePluginconst DllReferencePlugin = require(&#x27;webpack/lib/DllReferencePlugin&#x27;);module.exports = smart(webpackCommonConf, &#123; mode: &#x27;development&#x27;, module: &#123; rules: [ &#123; test: /\\.js$/, loader: [&#x27;babel-loader&#x27;], include: srcPath, exclude: /node_modules/ // 第二，不要再转换 node_modules 的代码 &#125;, ] &#125;, plugins: [ new webpack.DefinePlugin(&#123; // window.ENV = &#x27;production&#x27; ENV: JSON.stringify(&#x27;development&#x27;) &#125;), // 第三，告诉 Webpack 使用了哪些动态链接库 new DllReferencePlugin(&#123; // 描述 react 动态链接库的文件内容 manifest: require(path.join(distPath, &#x27;react.manifest.json&#x27;)), &#125;), ], devServer: &#123; port: 8080, progress: true, // 显示打包的进度条 contentBase: distPath, // 根目录 open: true, // 自动打开浏览器 compress: true, // 启动 gzip 压缩 // 设置代理 proxy: &#123; // 将本地 /api/xxx 代理到 localhost:3000/api/xxx &#x27;/api&#x27;: &#x27;http://localhost:3000&#x27;, // 将本地 /api2/xxx 代理到 localhost:3000/xxx &#x27;/api2&#x27;: &#123; target: &#x27;http://localhost:3000&#x27;, pathRewrite: &#123; &#x27;/api2&#x27;: &#x27;&#x27; &#125; &#125; &#125; &#125;&#125;)","categories":[{"name":"工程化","slug":"工程化","permalink":"http://example.com/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"工程化","slug":"工程化","permalink":"http://example.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"react-intl-universal踩坑","slug":"react-intl-universal踩坑日记","date":"2021-09-19T16:00:00.000Z","updated":"2021-11-10T05:45:02.013Z","comments":true,"path":"2021/09/20/react-intl-universal踩坑日记/","link":"","permalink":"http://example.com/2021/09/20/react-intl-universal%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/","excerpt":"","text":"react-intl-universal踩坑前言： 在业务测试过程中发现了一个bug(不是我干的)，面包屑没有按照多语言进行翻译，任务分配给了一个刚来的小伙子，他也不会正好来请教我，于是乎有了这次经历 解决思路： 在我们公司项目中，使用多语言都是采用公司封装的utils写的,import intl from &#39;utils/intl&#39;;,于是我找到了源码，看看这个intl到底是个啥玩意儿。 不看不知道，一看吓一跳，往下看（好家伙，原来这就是封装） 于是去搜了一下这个包，发现是阿里巴巴的，[react-intl-universal](alibaba/react-intl-universal: Internationalize React apps. Not only for React.Component but also for Vanilla JS. (github.com)),可惜全是英文文档，看不太懂，没关系，继续搜索 接下来，在代码里进行console.log把intl打印出来，发现在它的locales内部有对应语言的编码，但是通过intl.get方法去取出来，却什么也没打印出来 再接下来，继续搜索，带着疑问，为什么明明有编码intl.get()方法却取不到对应的值，在找了好几个文章之后，终于在CSDN一篇文章找到了答案使用react-intl-universal进行组件和非组件的国际化,文章说到了，非组件的js文件中使用，发现并不起作用(- -!，原来这么简单，我还是太菜了) 解决方案：​ 将定义的需要多语言转换的面包屑数组移到组件内部，在本地测试发现神奇般的好了，完美解决 后续：对于react-intl-universal的忽视让我心怀愧疚，于是创了个demo进行基本使用，了解是怎么做国际化多语言装换的 项目结构： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import React, &#123; Component &#125; from &#x27;react&#x27;;import intl from &#x27;react-intl-universal&#x27;import &#123; withRouter &#125; from &quot;react-router-dom&quot;;class App extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; initDone: false &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;div&gt;&#123;intl.get(&#x27;login.username&#x27;)&#125;&lt;/div&gt; &lt;div&gt;&#123;intl.get(&#x27;editor.item.name&#x27;)&#125;&lt;/div&gt; &lt;button onClick=&#123;this.handleLanguage.bind(this)&#125;&gt;EN/中&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;//生命周期Object.assign(App.prototype, &#123; componentDidMount() &#123; let &#123; location &#125; = this.props let ps = this.parseQueryString(location.search) let currentLocale = ps.language || &#x27;zh-CN&#x27; intl.init(&#123; currentLocale: currentLocale, commonLocaleDataUrls: &#123; &#x27;zh&#x27;: false, &#x27;en&#x27;: false &#125;, locales: &#123; // 根据不同的语言，拿到不同的json文件 [currentLocale]: require(`./locales/$&#123;currentLocale&#125;`).default &#125; &#125;).then(() =&gt; &#123; this.setState(&#123; initDone: true &#125;) &#125;) &#125;, handleLanguage() &#123; let &#123; location &#125; = this.props let ps = this.parseQueryString(location.search) // 对url进行操作，请求不同json配置 if (ps.language === &#x27;en-US&#x27;) &#123; this.props.history.push(&#x27;?language=zh-CN&#x27;) &#125; else if (ps.language === &#x27;zh-CN&#x27;) &#123; this.props.history.push(&#x27;?language=en-US&#x27;) &#125; else &#123; this.props.history.push(&#x27;?language=en-US&#x27;) &#125; // 刷新页面，组件重新加载 window.location.reload() &#125;, parseQueryString(url) &#123; var params = &#123;&#125;; var arr = url.split(&quot;?&quot;); if (arr.length &lt;= 1) &#123; return params; &#125; arr = arr[1].split(&quot;&amp;&quot;); for (var i = 0, l = arr.length; i &lt; l; i++) &#123; var a = arr[i].split(&quot;=&quot;); params[a[0]] = a[1]; &#125; return params; &#125;&#125;)export default withRouter(App); zh-CH.js 1234567import editor from &#x27;./zh-CN_Editor.js&#x27;export default (&#123; login: &#123; &quot;username&quot;: &quot;用户名&quot;, &#125;, editor: editor&#125;) zh-CN_Editor.js 123456export default (&#123; item: &#123; name: &#x27;邱文斌&#x27; &#125;&#125;) en-US.js 1234567import editor from &#x27;./en-US_Editor.js&#x27;export default (&#123; login: &#123; &quot;username&quot;: &quot;Username&quot; &#125;, editor: editor &#125;) en-US_Editor.js 123456export default (&#123; item: &#123; name: &#x27;Qiuwenbin&#x27; &#125;&#125;) 总结：项目是基于dva构建的项目工程，所以在项目中多语言应该是在点击语言选择框后将语言的对应locales数据保存进去，这样在各个页面中都能够通过intl.get()方式获取到当前语言对应的值，也方便业务测试人员进行语种信息维护","categories":[{"name":"项目相关","slug":"项目相关","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"项目相关","slug":"项目相关","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/"}]},{"title":"实现数组扁平化方法总结","slug":"实现数组扁平化方法","date":"2021-03-02T07:07:44.213Z","updated":"2021-11-15T03:39:47.941Z","comments":true,"path":"2021/03/02/实现数组扁平化方法/","link":"","permalink":"http://example.com/2021/03/02/%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96%E6%96%B9%E6%B3%95/","excerpt":"","text":"数组的扁平化其实就是将一个嵌套多层的数组 array（嵌套可以是任何层数）转换为只有一层的数组。举个简单的例子，假设有个名为 flat 的函数可以做到数组扁平化，效果如下面这段代码所示。 12let a = [1, [2, [3, 4]]];// 输出[1,2,3,4] 扁平化既是将多维数组，输出成意一维数组，接下来我们就来实现如何将数组拍平的 flat 方法。 方法一：递归实现 1234567891011121314151617// 递归实现的思路就是循环遍历数组，对每一项做不同判断，如果当前项仍是数组，则继续递归拍平let a = [1,[2,[3,4]]];function flat (arr)&#123; let result = []; for (let i = 0; i&lt; arr.length; i++)&#123; // 判断当前项是否为数组，是则递归，否则push到result中 if(Array.isArray(arr[i]))&#123; result = result.concat(flat(arr[i])) &#125;else&#123; result.push(arr[i]) &#125; &#125; return result;&#125;// console.log(flat(a)) [1,2,3,4] 方法二：reduce方式实现 1234567891011//reduce实现跟第一种方法很相似，只不过我们使用reduce的灵活参数来简化代码，达到相同的目的。let a = [1,[2,3,[4,5]]];function flat(arr)&#123; return arr.reduce((pre,next)=&gt;&#123; return pre.concat(Array.isArray(next)?flat(next):next) &#125;,[])&#125;//console.log(flat(a)) [1,2,3,4,5] 方法三：扩展运算符实现 12345678910111213//通过扩展运算符与数组的some方法一起使用，同样能够实现数组拍平效果let a = [1,[2,[3,4,[5]]]];function flat(arr)&#123; // 先过滤出是数组的项，通过扩展运算符+concat方法拼接返回 while(arr.some(item=&gt;Array.isArray(item)))&#123; arr = [].concat(...arr) &#125; return arr;&#125;// console.log(flat(a)) [1,2,3,4,5] 方法四：ES6数组的flat方法实现 123456789// 在ES6中数组的flat方法可以直接实现数组扁平化，arr.flat([depth]),其中 depth 是 flat 的参数，depth 是可以传递数组的展开深度（默认不填、数值是 1），即展开一层数组。//参数也可以传进 Infinity，代表不论多少层都要展开let a1 = [1,[2,[3,4,[5]]]];function flat (arr)&#123; return arr.flat(Infinity)&#125;//console.log(flat(arr)) // [1,2,3,4,5]","categories":[{"name":"JS基础","slug":"JS基础","permalink":"http://example.com/categories/JS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"}]},{"title":"TypeScript学习","slug":"TypeScript学习","date":"2021-01-19T16:00:00.000Z","updated":"2021-12-21T08:36:46.330Z","comments":true,"path":"2021/01/20/TypeScript学习/","link":"","permalink":"http://example.com/2021/01/20/TypeScript%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"TypeScript学习基本类型 类型声明 通过类型声明可以指定TS中变量（参数、形参）的类型，指定类型后为变量赋值，TS编译器会自动检查值是否符合类型声明，否则报错 语法 let 变量:类型； let 变量:类型 = 值； function fn（参数:类型,参数:类型）:类型&#123; ... &#125; 123456789101112131415161718+ ##### 自动类型判断 &gt; `TS`拥有自动的类型判断机制，当对变量的声明和赋值是同时进行的，`TS编译器`会自动判断类型 &gt; &gt; 对于函数来说，参数传多或传少在`TS`中都会报错. + 如： ```tsx let c = false; //声明变量c和赋值同事进项，再次修改已经确定了它的数据类型了 c=&#x27;123&#x27; // tsc 编译会报错 // 不能将类型“string”分配给类型“boolean”。 function sum(a: number, b: number): number &#123; return a + b &#125; sum(123, &#x27;456&#x27;,123) //类型“string”的参数不能赋给类型“number”的参数。 应有 2 个参数，但获得 3 个。 注意&#x2757; 即使编译会报错，但是还是能够编译成功 类型 类型 例子 描述 number 1,213,-12 任意数字 string ‘hello’,’11’ 任意字符串 boolean true,false 布尔值true或者false any * 任意类型；不建议使用 unknow * 类型安全的any void 空值(undefined) 没有值或者undefined never 没有值 不能是任何值 object 对象 任意的js对象 array [1,2,3] 任意js数组 tuple [3,4] 元祖，ts新增类型，固定长度数组 enum enum{A,B} 枚举，ts新增类型 | let b:’male’ | ‘female’ 可以用来连接多个类型，b可以取值为其中之一 ? {name:string,age?:number} 可以用?来表示可选属性 type type myType = string; let a :myTtype ; 类型别名，myType就表示string类型 注意:exclamation: any和`unknown的区别 any 是任意类型，如果一个变量声明为any，再将这个变量赋值给另一个变量，则会导致另一变量也关闭类型检查，而`unknown赋值给另一变量，类型检查不会关闭 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// anylet b: any;b = false;b = &#x27;123&#x27;;let c: string;c = b // c 类型为string b赋值给c 导致c关闭了类型检查//unknownlet b: unknown;b = false;b = &#x27;123&#x27;;let c: string;c = b // ts类型检查 会提示不能将类型“unknown”分配给类型“string”// 类型断言let b: unknown;b = &#x27;123&#x27;;let c: string;// c = &lt;String&gt; bc = b as string; // as 类型断言用来告诉解析器，b就是string类型//对象定义// [propName:string]:any 表示任意类型的属性都可以，但是必须有name属性let c:&#123;name:string,[propName:string]:any&#125;c=&#123; name:&quot;Findly&quot;, age:18&#125;// 数组定义let e:string[];let e:Array&lt;string&gt;// 元祖 固定长度的数组let h:[string,string]h=[&#x27;hello&#x27;,&#x27;w&#x27;] // 固定只能是定义时的个数// 枚举enum Gender&#123; Male, Female&#125;let i: &#123; name: string, gender: Gender&#125;i = &#123; name: &quot;邱文斌&quot;, gender: Gender.Male&#125; 编译选项 自动编译文件 编译文件时使用-w命令，编译器会自动监视文件变化并且在文件发生变化时自动编译为js文件 1tsc xxx.ts -w 自动编译整个项目 根目录添加tsconfig.json文件，TS编译器根据这个配置文件来对ts进行编译 tsconfig.json配置选项 include 定义希望被编译的文件所在目录 默认值：[/] 使用 1&quot;include&quot;: [&quot;./src/**/*&quot;], // 路径 ** 表示任意目录，*表示任意文件 exclude 排除不希望被编译的文件目录 默认值：[“node_modules”,”bower_component”] 使用 1&quot;exclude&quot;:[ &quot;node_modules&quot;, &quot;**/*.spec.ts&quot;] extends 定义被继承的配置文件 使用 1&quot;extends&quot;:&quot;./config/base&quot; // 当前配置文件会自动包含config下的base.json配置信息 files 指定被编译的文件 使用 1234&quot;files&quot;:[ &#x27;index.ts&#x27;, &#x27;app.ts&#x27;] // 只有定义的这两个ts文件会被编译 compilerOptions 编译选项是配置文件中非常重要也是比较复杂的配置选项 在compilerOptions中包含多个子选项，用来完成对编译的配置 项目选项 target 设置ts代码编译的目标版本 可选值：ES3(默认)、ES5、ES6/ES2015… 使用 &quot;compilerOptions&quot;:&#123; &quot;target&quot;:&#39;ES6&#39; &#125; 123456789101112131415161718+ `module` + 设置模块化的规范 + 可选值：es2015、commonjs...+ `lib` + 指定代码运行时所包含的库（宿主环境） + 可选值:ES5、ES6...、DOM、webWorker + `一般不需要设置，除非在node端使用时需要设置一下，默认就是浏览器环境`+ `outDir` + 编译后的输出目录 + ```js &quot;outDir&quot;:&#x27;./dist&#x27; allowJS 可选值：true|false 如果为false则不会对js后缀文件进行编译 类 TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 public、private 和 protected public 表示属性或方法是公有的，可以在任何地方被访问到，默认所有属性和方法都是public private表示属性或方法是私有的，不能在声明它的类的外部访问 protected表示属性或方法是受保护的，不能在类外部访问到，但是在子类中是允许访问的 readonly只读属性关键字无法修改属性，只允许出现在属性声明或索引签名或构造函数中；其他访问修饰符同时存在的话，需要写在其后面, abstract 用于定义抽象类和其中的抽象方法；抽象类不能被实例化，抽象类中的抽象方法必须被子类实现；一般用来继承的时候使用 123456789101112131415161718class Person &#123; name; private readonly age; protected gender; constructor(name: string, age: number, gender: string) &#123; this.name = name; this.age = age; this.gender = gender &#125;&#125;let per = new Person(&#x27;Findly&#x27;, 18, &#x27;男&#x27;)console.log(per)console.log(per.name)// 可以看到age 和 gender是不能访问的 会编译报错console.log(per.age)console.log(per.gender) 属性的封装 在类中我们可以通过setter、getter来做到属性的存取器；但是在TS中，可以直接使用set/get 来达到设置setter/getter的目的 123456789101112131415161718192021222324252627class myClass &#123; private _name: string; private _age: number; constructor(name, age) &#123; this._name = name; this._age = age &#125; sayHello(): void &#123; console.log(`this is my name $&#123;this._name&#125;`) &#125; // getName() &#123; // return this.name // &#125; // setName(value: string) &#123; // this.name = value // &#125; get name() &#123; return this._name &#125; set name(value: string) &#123; this._name = value &#125;&#125;// name属性是私有的通过实例是拿不到的，但是通过get方法可以拿到 所以可以直接调用 实例.name方法得到私有属性nameconst myclass = new myClass(&#x27;myclass&#x27;, 19)console.log(myclass.name) // 打印 myclass 属性定义的简写 12345678910111213// class myClass &#123;// private _name: string;// private _age: number;// constructor(name, age) &#123;// this._name = name;// this._age = age// &#125;// &#125;// 在constructor中定义属性类型。可以省略this.name赋值过程class myClass &#123; constructor(public name: string, public age: number) &#123; &#125;&#125; 12345678910111213141516171819202122232425262728// abstract 定义抽象类 不能被实例化abstract class Person &#123;name;public age;gender;constructor(name: string, age: number, gender: string) &#123; this.name = name; this.age = age; this.gender = gender&#125;abstract sayName(); // 抽象方法不能具体实现&#125;class Student extends Person &#123;jobconstructor(name, age, gender, job: string) &#123; super(name, age, gender) this.job = job&#125;sayName() &#123; // 父类的抽象方法 子类必须实现 console.log(this.name)&#125;&#125;const p = new Student(&#x27;Findly&#x27;, 18, &#x27;男&#x27;, &#x27;coder&#x27;)console.log(&#x27;p==&#x27;, p) //Student &#123;name: &#x27;Findly&#x27;, age: 18, gender: &#x27;男&#x27;, job: &#x27;coder&#x27;&#125; 接口 接口用来定义一个类结构，限制类，用来定义一个类中应该包含哪些属性和方法，同时接口也可以当做类型声明去使用，类似type定义的类型声明 1234567891011interface myInterface &#123; name: string; age: number;&#125;const obj: myInterface = &#123; name: &quot;sss&quot; age: 18, gender: &#x27;男&#x27; // 不能将类型“&#123; name: string; age: number; gender: string; &#125;”分配给类型“myInterface”。对象文字可以只指定已知属性，并且“gender”不在类型“myInterface”中。&#125; 接口继承接口12345678910interface Alarm &#123; alert(): void;&#125;interface LightableAlarm extends Alarm &#123; lightOn(): void; lightOff(): void;&#125;//LightableAlarm 继承了 Alarm，除了拥有 alert 方法之外，还拥有两个新方法 lightOn 和 lightOff implements关键字用于类去实现一个接口 123456789101112131415161718192021interface myInterface &#123; name: string; age: number; sayHello(): void;&#125;class myClass implements myInterface &#123; // 接口中定义的属性和方法，类中必须要实现 name: string; age: number; constructor(name, age) &#123; this.name = name; this.age = age &#125; sayHello(): void &#123; console.log(`this is my name $&#123;this.name&#125;`) &#125;&#125;const myclass = new myClass(&#x27;myclass&#x27;, 19)myclass.sayHello() // this is my name myclass 注意&#x2757; type和interface的区别 type可以用于其他类型，比如联合类型、元祖类型、基本类型；interface不能 123456789101112131415type PartialPointX = &#123; x: number &#125;;type PartialPointY = &#123; y: number &#125;;// union(联合)type PartialPoint = PartialPointX | PartialPointY;// tuple(元祖)type Data = [PartialPointX, PartialPointY];//primitive(原始值)type Name = Number;// typeof的返回值let div = document.createElement(&#x27;div&#x27;);type B = typeof div; interface可以多次定义，并被视为合并所有声明成员，type不支持 12345678interface Point &#123; x: number;&#125;interface Point &#123; y: number;&#125;const point: Point = &#123; x: 1, y: 2 &#125;; type能使用in关键字生成映射类型，interface不行 12345678910type Keys = &#x27;firstname&#x27; | &#x27;surname&#x27;;type DudeType = &#123; [key in Keys]: string;&#125;;const test: DudeType = &#123; firstname: &#x27;Pawel&#x27;, surname: &#x27;Grzybek&#x27;,&#125;; 接口中的所有属性都不能有实际的值，接口只定义对象的接口，而不考虑实际值，在接口中所有的方法都是抽象方法 泛型 在定义函数或者类时，如果遇到类型不明确时，只有在函数运行才能确定类型时就可以使用泛型 1234567891011121314151617181920212223242526272829303132333435function fn&lt;T&gt;(a: T): T &#123; return a&#125;fn(10) // 会自动给泛型T 赋值为numberfn&lt;string&gt;(&#x27;hello&#x27;) // 可以在调用的时候 指定泛型T的类型// 泛型可以指定多个function fn2&lt;T, K&gt;(a: T, b: K): T &#123; console.log(b) return a&#125;fn2&lt;number, string&gt;(123, &#x27;hello&#x27;)// 泛型可以通过extends实现接口 实现范围控制interface Inter &#123; length: number&#125;// 泛型T extends Inter 表示泛型实现了Inter接口的类 且有length属性function fn3&lt;T extends Inter&gt;(a: T): number &#123; return a.length&#125;fn3(&#x27;123&#x27;); // string类型可以通过fn3(11) //number类型不能通过没有length属性fn3([123, 123]) // 数组类型可以通过// 泛型作用在类上class myClass&lt;T&gt;&#123; name:T; constructor(name:T)&#123; this.name = name &#125;&#125;const per = new myClass&lt;string&gt;(&#x27;Findly&#x27;) // 在实例化的时候声明泛型T的类型","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"}]},{"title":"简单的脚手架实现过程","slug":"简单的脚手架实现","date":"2020-10-29T16:00:00.000Z","updated":"2021-11-02T09:01:47.027Z","comments":true,"path":"2020/10/30/简单的脚手架实现/","link":"","permalink":"http://example.com/2020/10/30/%E7%AE%80%E5%8D%95%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"前置内容Package.json中bin的作用 内部命令对应的可执行文件的路径; #!/usr/bin/env node 到底是什么？ #! shenbang 为了指定脚本的解释程序 /usr/bin/env就是告诉系统可以在PATH目录中查找内容 所以配置#!/usr/bin/env node, 就是解决了不同的用户node路径不同的问题，可以让系统动态的去查找node来执行你的脚本文件 简单的脚手架制作 初始化项目名称simaple,并执行yarn init命令得到package.json文件。 添加bin配置，并指向当前目录下的cli.js文件，执行cli命令 在文件夹根目录添加cli.js文件 脚手架的主要工作内容有两个： 通过命令行交互询问用户问题 根据用户的回答生成文件 注意cli.js文件头部一定要添加这段内容#!/usr/bin/env node 执行yarn link，将simaple作为外链可以全局引用 创建templates模板文件夹，定义模板文件，比较简单只有一个index.html和style.css文件，内容如下： 接下来完善cli.js文件内容，通过ejs将模板文件输出到目标文件夹demo中去 1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/usr/bin/env node// node cli 应用入口必须要有这样的文件头，如果是mac需要修改此文件的读写权限为755// 具体通过chmod 755 cli.js实现修改// 脚手架的工作过程//1.通过命令行交互询问用户问题// 2. 根据用户的回答结果生成文件// 发起命令行交互询问const inquirer = require(&#x27;inquirer&#x27;);const path = require(&#x27;path&#x27;);const fs = require(&#x27;fs&#x27;);const ejs = require(&#x27;ejs&#x27;);// 发起命令行询问inquirer .prompt([ &#123; type: &#x27;input&#x27;, name: &#x27;name&#x27;, message: &#x27;Project name?&#x27;, &#125;, ]) .then((resp) =&gt; &#123; // 根据用户回答的结果生成文件 // 模板目录 const templateDir = path.join(__dirname, &#x27;templates&#x27;); // 目标目录 const destDir = process.cwd(); fs.readdir(templateDir, (err, files) =&gt; &#123; if (err) throw err; files.forEach((file) =&gt; &#123; // console.log(&#x27;file&#x27;, file); // 通过模板引擎渲染文件 ejs.renderFile(path.join(templateDir, file), resp, (err, result) =&gt; &#123; if (err) throw err; // console.log(&#x27;result==&#x27;, result); // 写入目标路径 fs.writeFileSync(path.join(destDir, file), result); &#125;); &#125;); &#125;); &#125;); 最后进入到demo文件夹内部,执行simaple命令，得到模板文件 通过这个小demo了解了脚手架的工作内容，接下来就继续深入开发一个可以投入生产使用的脚手架工具","categories":[{"name":"工程化","slug":"工程化","permalink":"http://example.com/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"工程化","slug":"工程化","permalink":"http://example.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"浏览器之跨域","slug":"浏览器之跨域","date":"2020-10-19T16:00:00.000Z","updated":"2021-12-21T08:37:22.199Z","comments":true,"path":"2020/10/20/浏览器之跨域/","link":"","permalink":"http://example.com/2020/10/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E8%B7%A8%E5%9F%9F/","excerpt":"","text":"浏览器之跨域 什么是跨域？ 怎么样算跨域？ 如何解决跨域？ 1.跨域的来源跨域问题的来源是浏览器为了请求安全而引入的基于同源策略的安全特性。同源策略是浏览器一个非常重要的安全策略，基于这个安全策略可以限制非同源的内容与当前页面进行交互和通信，来达到减少被攻击的目的。我们也要明白一个重点：跨域是浏览器的限制，服务端并不存在跨域的概念;当产生跨域问题时，我们可以通过JSONP、CORS,反向代理、postMessage等方式来解决 2.跨域的判定 如上图所示，一个 origin 由协议（Protocol）、主机名（Host）和端口（Port）组成，这三块也是同源策略的判定条件，只有当协议、主机名和端口都相同时，浏览器才判定两者是同源关系，三者任一不同则为跨域 3.跨域的解决方案前端常见的跨域解决方案有JSONP、使用Nginx或者Node中间件做代理，利用CORS,postMessage等方式； JSONP JSONP的原理主要是利用&lt;script&gt;,link,&lt;img&gt;等标签的特性在加载资源文件时不受同源策略的限制能够实现跨域获取数据，但是需要前后端一起配合才能实现并且只能支持GET请求方式。具体步骤如下： 定义一个回调函数，并且用DOM方法创建一个script元素 指定要请求的URL，并将回调函数作为一个参数传递过去 将script便签插入到当前文档中，请求开始 服务器接收到传递过来的参数，然后将回调函数和数据以调用的形式传入 当script标签接收到响应中的脚本代码后，就会自动执行 12345678910111213141516171819202122232425262728293031323334353637function createScript(url, charset) &#123; const script = document.createElement(&#x27;script&#x27;); script.setAttribute(&#x27;type&#x27;, &#x27;text/javascript&#x27;); charset &amp;&amp; script.setAttribute(&#x27;charset&#x27;, charset); script.setAttribute(&#x27;src&#x27;, url); script.async = true; return script;&#125;function jsonp(url, onsuccess, onerror, charset) &#123; const hash = Math.random().toString().slice(2); window[&#x27;jsonp&#x27; + hash] = function (data) &#123; if (onsuccess &amp;&amp; typeof(onsuccess) === &#x27;function&#x27;) &#123; onsuccess(data);&#125; &#125;const script = createScript(url + &#x27;?callback=jsonp&#x27; + hash, charset);// 监听加载成功的事件，获取数据，这个位置用了两个事件onload和onreadystatechange是为了 兼容IE，因为IE9之前不支持onload事件，只支持onreadystatechange事件script.onload = script.onreadystatechange = function() &#123; //若不存在readyState事件则证明不是IE浏览器，可以直接执行，若是的话，必须等到状态变为loaded或complete才可以执行if (!this.readyState || this.readyState === &#x27;loaded&#x27; || this.readyState=== &#x27;complete&#x27;) &#123;script.onload = script.onreadystatechange = null; // 移除该script的DOM对象if (script.parentNode) &#123; script.parentNode.removeChild(script); &#125;// 删除函数或变量 window[&#x27;jsonp&#x27; + hash] = null; &#125;&#125;; script.onerror = function() &#123; if (onerror &amp;&amp; typeof(onerror) === &#x27;function&#x27;) &#123;onerror(); &#125;&#125;// 添加标签，发送请求 document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(script);&#125; 相关知识-跨域脚本报错怎么拿到相关信息？ 当引入跨域的脚本（比如用了 apis.google.com 上的库文件）时，如果这个脚本有错误，因为浏览器的限制（根本原因是协议的规定），是拿不到错误信息的。当本地尝试使用window.onerror去记录脚本的错误时，跨域脚本的错误只会返回 Script error。 而 HTML5 新的规定，是可以允许本地获取到跨域脚本的错误信息的，但有两个条件：一是跨域脚本的服务器必须通过 Access-Control-Allow-Origin 头信息允许当前域名可以获取错误信息，二是网页里的 script 标签也必须指明 src 属性指定的地址是支持跨域的地址，也就是 crossorigin 属性。有了这两个条件，就可以获取跨域脚本的错误信息 CORS CORS通信流程是浏览器自动完成，不需要用户参与，其核心点是服务器，只要服务器实现了 CORS接口就可以实现跨源通信了。虽然是浏览器自动完成，但是浏览器其实还是根据请求时字段 的不同分为简单请求和非简单请求的; 简单请求 请求方法是一下三种方法之一:HEAD、GET、POST; HTTP的头信息不超出以下几种字段:Accept、Accept-Language、Content-Language、Last- Event-ID、Content-Type(其值为application/x-www-form-urlencoded、multipart/form- data、text/plain三个中的一个)。 非简单请求 不是简单请求的就是非简单请求，非简单请求是那种对服务器有特殊要求的请求，比如请求方法 是PUT或Delete，或者Content-Type字段的类型是application/json。 浏览器发起预检请求，该请求的请求方法是options，该请求是用来询问的; 服务器收到“预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control- Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 如果浏览器否定了“预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字 段，这时浏览器就会认定服务器不同意预检请求，触发错误; 如果浏览器通过了“预检”请求，以后每次浏览器正常的CORS请求就跟简单请求一样，会有一个 Origin头信息字段，服务器的回应也会有一个Access-Control-Allow-Origin头信息字段; 过服务端返回的 Access-Control-Allow-* 判定请求是否被允许。 Access-Control-Allow-Origin 表示允许的来源 Access-Control-Allow-Methods 表示允许的请求方法 Access-Control-Allow-Headers 表示允许的请求头 Access-Control-Allow-Credentials 表示允许携带认证信息 反向代理 向代理解决跨域问题的方案依赖同源的服务端对请求做一个转发处理，将请求从跨域请求转换成同源请求,在页面同域下配置一套反向代理服务，页面请求同域的服务端，服务端请求上游的实际的服务端，之后将结果返回给前端。所以反向代理前端几乎不需要做什么。","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"前端实现点击下载文件的几种方法","slug":"前端实现点击下载文件的几种方法","date":"2020-08-29T16:00:00.000Z","updated":"2021-11-23T09:55:45.686Z","comments":true,"path":"2020/08/30/前端实现点击下载文件的几种方法/","link":"","permalink":"http://example.com/2020/08/30/%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%87%BB%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"实现点击下载文件的几种方法可以看看简书归纳的几种方法:前端实现下载的几种方法 后端设置header信息实现下载 12header(&#x27;Content-type&#x27;:image-jpeg);header(&quot;Content-Disposition:attachment;filename=&#x27;download.jpg&#x27;&quot;) 局限：需要后端配合 使用window.open()或者location.href或者直接使用标签将页面跳转到文件地址,如果文件时浏览器无法打开的文件类型,浏览器会自动下载该文件；或者添加download属性进行下载；download属性告诉浏览器这个a标签不是打开页面预览而是进行下载。 局限： 会自动打开一个页面，体验不好 图片文本等浏览器能够打开的文件无法下载 使用FileSaver.js下载 手动下载xml文件123456789101112131415161718192021222324252627const downLoadXls = (data, filename) =&gt; &#123; const blob = new Blob([data], &#123; type: &#x27;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&#x27;, &#125;); if (typeof window.navigator.msSaveBlob !== &#x27;undefined&#x27;) &#123; // 兼容IE，window.navigator.msSaveBlob：以本地方式保存文件 window.navigator.msSaveBlob(blob, decodeURI(filename)); &#125; else &#123; // 创建新的URL并指向File对象或者Blob对象的地址 const blobURL = window.URL.createObjectURL(blob); // 创建a标签，用于跳转至下载链接 const tempLink = document.createElement(&#x27;a&#x27;); tempLink.style.display = &#x27;none&#x27;; tempLink.href = blobURL; tempLink.setAttribute(&#x27;download&#x27;, decodeURI(filename)); // 兼容：某些浏览器不支持HTML5的download属性 if (typeof tempLink.download === &#x27;undefined&#x27;) &#123; tempLink.setAttribute(&#x27;target&#x27;, &#x27;_blank&#x27;); &#125; // 挂载a标签 document.body.appendChild(tempLink); tempLink.click(); document.body.removeChild(tempLink); // 释放blob URL地址 window.URL.revokeObjectURL(blobURL); &#125;&#125;; 在线预览Excel文件 微软接口实现： 只读不可编辑 文件的下载地址(可以直接访问的，公共资源要注意文档如果有保密性的话谨慎使用，因为url是直接暴露给微软的) 将文件地址url encode一下 调用微软接口预览(必须为 http:// 或 https:// 形式，文档必须是 Word、Excel 或 PowerPoint 文档)12345678910 // 文件的下载地址(可直接访问的)fileUrl // 将 URL encode 一下；(因为当字符串数据以url的形式传递给web服务器时,字符串中是不允许出现空格和特殊字符的)let newFileUrl = encodeURIComponent(fileUrl) // 预览window.open(`https://view.officeapps.live.com/op/view.aspx?src=`$&#123;newFileUrl&#125;, &#x27;_blank&#x27;) 转PDF 直接转HTML 后端将excel数据传给前端，前端利用插件实现效果展示（sheet.js） 在线预览PDF文件 通过后台返回url 直接通过window.open(ulr)打开 react实现pdf文档可翻页查看，可放大缩小及全屏等功能，选的是 react-pdf 插件， react-file-viewer 插件也试了下，可以查看pdf，不过是一次性加载全部，最终选了前者 在线预览Word文件 微软接口实现：只读不可编辑 使用Mammoth.js旨在转换 .docx 文档（例如由 Microsoft Word 创建的文档），并将其转换为 HTML。","categories":[{"name":"项目相关","slug":"项目相关","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"项目相关","slug":"项目相关","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/"}]},{"title":"浅谈call和apply实现原理","slug":"浅谈call和apply实现原理","date":"2020-08-08T16:00:00.000Z","updated":"2021-11-10T05:52:20.688Z","comments":true,"path":"2020/08/09/浅谈call和apply实现原理/","link":"","permalink":"http://example.com/2020/08/09/%E6%B5%85%E8%B0%88call%E5%92%8Capply%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"","text":"浅谈call和apply实现原理Call（thisArg, arg1, arg2, …）简单介绍一下call方法，MDN对它的解释是，call 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。简单看下如下代码： 12345678const foo = &#123; value:1&#125;function bar()&#123; console.log(this.value)&#125;bar.call(foo); //1 我对它的理解是，A.call(B),那么A中的this就指向了B这个对象；即call方法能够改变它的调用者的this指向,在这里我们需要注意的是，如果我们没有给传递thisArg给call方法，this的值将会绑定为全局对象,看如下代码： 12345let data = &#x27;Findly&#x27;;function disPlay()&#123; console.log(&#x27;data的值是?&#x27;,this.data);&#125;display.call(); // data的值是?,Findly 接下来，我们就来深究一下它的原理，别着急，先看看下面的代码： 1234567891011121314151617const foo = &#123; value:1&#125;function bar()&#123; console.log(this.value)&#125;bar.call(foo); //1----------------------------const foo = &#123; value:1, bar:function()&#123; console.log(this.value) &#125;&#125;foo.bar(); //1 我们发现这两块代码执行结果都是一样的，所以我们可以根据第二块代码来实现call； 将函数设计为某个对象的属性； 执行该函数； 删除该函数； 123foo.fn = bar;foo.fn();delete foo.fn; 所以根据上面的思路，可以实现自己的call方法： 123456789101112131415Function.prototype.myCall=function(context)&#123; // 得到myCall的this，也就是调用myCall的对象，那个对象调用myCall方法，那么myCall的this就指向这个对象； context.fn = this; context.fn(); delete context.fn;&#125;// 测试如下let foo = &#123; value:&#x27;Findly&#x27;&#125;function bar()&#123; console.log(this.value)&#125;bar.myCall(foo); // &#x27;Findly&#x27; 接下来就要考虑到call的第二个参数，指定参数列表；改良版如下 123456789101112131415161718Function.prototype.myCall = function(context) &#123; // this指向调用call的对象 if (typeof this !== &#x27;function&#x27;) &#123; // 调用call的若不是函数则报错 throw new TypeError(&#x27;Error&#x27;); &#125; const args = [...arguments].slice(1); context = context || window; // 将调用call函数的对象添加到thisArg的属性中 context.fn = this; // 执行该属性 const result = context.fn(...arg); // 删除该属性 delete context.fn; // 返回函数执行结果 return result;&#125;; Apply(thisArg, [argsArray])从上面看来，call方法的作用和 apply 方法类似，区别就是call()方法接受的是参数列表，而apply()方法接受的是一个参数数组。 所以我们可以在call的基础上进行修改，以实现apply方法 12345678910111213141516Function.prototype.myApply = function (context) &#123; // 赋值作用域参数，如果没有则默认为 window，即访问全局作用域对象 context = context || window // 绑定调用函数（.call之前的方法即this，前面提到过调用call方法会调用一遍自身，所以这里要存下来） context.fn = this // 执行调用函数，需要对是否有参数做判断，记录拿取返回值 let result if (arguments[1]) &#123; result = context.fn(...arguments[1]) &#125; else &#123; result = context.fn() &#125; // 销毁调用函数，以免作用域污染 Reflect.deleteProperty(context, &#x27;fn&#x27;) return result&#125;","categories":[{"name":"JS基础","slug":"JS基础","permalink":"http://example.com/categories/JS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"}]},{"title":"浅谈instanceof的实现原理","slug":"浅谈instanceof实现原理","date":"2020-08-08T16:00:00.000Z","updated":"2021-11-10T05:52:40.672Z","comments":true,"path":"2020/08/09/浅谈instanceof实现原理/","link":"","permalink":"http://example.com/2020/08/09/%E6%B5%85%E8%B0%88instanceof%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"","text":"浅谈instanceof的实现原理​ 我们知道typeof一般用来判断基本数据类型，如string,number,boolean,undefined,Symbol,但是判断的null比较特殊虽然结果是object，但它的类型并不是object,至于为什么？☞详情戳这里，所以对于复杂类型，typeof就比较无力，只能识别出是object但是并不能准确的得出是什么类型。 ​ instanceof可以用来判断对象的具体类型。它的主要依据就是判断一个实例是否属于某一类型. 1234let People = function ()&#123;&#125;;const people = new People();people instanceof People // true ​ 在MDN上，解释了它的原理，**instanceof** 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上； 12345678910111213function Car(make, model, year) &#123; this.make = make; this.model = model; this.year = year;&#125;const auto = new Car(&#x27;Honda&#x27;, &#x27;Accord&#x27;, 1998);console.log(auto instanceof Car);// expected output: trueconsole.log(auto instanceof Object);// expected output: true ​ 那么接下来就来分析一下它的原理: 12345678910111213141516171819202122/** * @description: * @param &#123;*&#125; left 实例对象 * @param &#123;*&#125; right 构造函数 * @return &#123;*&#125; */function myInstanceof(left,right)&#123; if(typeof left!==&#x27;object&#x27;||left===null) return false; // 先获得等号右边参数的原型对象； let rightPrototype = right.prototype; // 得到左边参数的隐式原型； left = left.__proto__; // 可以用Object.getPrototypeOf(left) while(true)&#123; if(left === null)&#123; return false; &#125; if(left === rightPrototype)&#123; return true; &#125; left = left.__proto__ &#125;&#125; ​ 根据MDN上的原理。判断构造函数的prototype是否出现在实例对象的原型链上，就能判断它是那种具体的对象了。 总结对于基本类型的数据，我们用typeof来判断完全够用，对于复杂的数据类型，我们需要知道它的具体对象类型，则需要使用instanceof来进行判断，当然还有更好的方法，比如Object.prototype.toSting.call，会得到具体的数据类型，这也是目前来说最准确的方法了；","categories":[{"name":"JS基础","slug":"JS基础","permalink":"http://example.com/categories/JS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"}]}],"categories":[{"name":"项目相关","slug":"项目相关","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/"},{"name":"工程化","slug":"工程化","permalink":"http://example.com/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"JS基础","slug":"JS基础","permalink":"http://example.com/categories/JS%E5%9F%BA%E7%A1%80/"},{"name":"框架-React","slug":"框架-React","permalink":"http://example.com/categories/%E6%A1%86%E6%9E%B6-React/"},{"name":"JS进阶","slug":"JS进阶","permalink":"http://example.com/categories/JS%E8%BF%9B%E9%98%B6/"},{"name":"项目部署","slug":"项目部署","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/categories/TypeScript/"},{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"项目相关","slug":"项目相关","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/"},{"name":"工程化","slug":"工程化","permalink":"http://example.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"},{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"},{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]}